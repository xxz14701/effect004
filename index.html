<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>å¢å¼·ç‰ˆå‹•æ…‹ç‰¹æ•ˆè¦†è“‹å™¨</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            background: linear-gradient(135deg, #1e3c72 0%, #2a5298 100%);
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            min-height: 100vh;
            color: white;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
        }

        h1 {
            text-align: center;
            margin-bottom: 30px;
            font-size: 2.5em;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.3);
            background: linear-gradient(45deg, #ff6b6b, #4ecdc4, #45b7d1);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }

        .upload-area {
            border: 3px dashed rgba(255,255,255,0.3);
            border-radius: 15px;
            padding: 40px;
            text-align: center;
            margin-bottom: 30px;
            transition: all 0.3s ease;
            background: rgba(255,255,255,0.1);
            backdrop-filter: blur(10px);
        }

        .upload-area:hover {
            border-color: rgba(255,255,255,0.6);
            background: rgba(255,255,255,0.15);
        }

        .upload-area.dragover {
            border-color: #4CAF50;
            background: rgba(76, 175, 80, 0.2);
        }

        input[type="file"] {
            display: none;
        }

        .upload-btn {
            background: linear-gradient(45deg, #4CAF50, #45a049);
            color: white;
            padding: 15px 30px;
            border: none;
            border-radius: 25px;
            cursor: pointer;
            font-size: 18px;
            transition: all 0.3s ease;
            box-shadow: 0 4px 15px rgba(0,0,0,0.2);
        }

        .upload-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(0,0,0,0.3);
        }

        .controls {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 20px;
            margin-bottom: 30px;
            background: rgba(255,255,255,0.1);
            padding: 20px;
            border-radius: 15px;
            backdrop-filter: blur(10px);
        }

        .control-group {
            min-width: 200px;
        }

        .control-group label {
            display: block;
            margin-bottom: 8px;
            font-weight: 600;
        }

        select, input[type="range"] {
            width: 100%;
            padding: 10px;
            border: none;
            border-radius: 8px;
            background: rgba(255,255,255,0.2);
            color: white;
            font-size: 16px;
        }

        select {
            cursor: pointer;
        }

        select option {
            background: #2a5298;
            color: white;
        }

        input[type="range"] {
            padding: 5px;
            background: rgba(255,255,255,0.1);
        }

        .media-container {
            position: relative;
            max-width: 100%;
            margin: 0 auto;
            border-radius: 15px;
            overflow: hidden;
            box-shadow: 0 10px 30px rgba(0,0,0,0.3);
            display: none;
            width: 300px;
            height: 300px;
        }

        #mediaElement {
            width: 100%;
            height: 100%;
            display: block;
            object-fit: contain;
        }

        #videoElement {
            width: 100%;
            height: 100%;
            display: block;
            object-fit: contain;
        }

        #effectCanvas {
            position: absolute;
            top: 0;
            left: 0;
            pointer-events: none;
            width: 100%;
            height: 100%;
        }

        .download-section {
            display: none;
            text-align: center;
            margin: 20px 0;
        }

        .download-options {
            background: rgba(255,255,255,0.1);
            padding: 20px;
            border-radius: 15px;
            margin: 20px 0;
            backdrop-filter: blur(10px);
        }

        .option-group {
            margin: 15px 0;
            text-align: left;
        }

        .option-group label {
            display: block;
            margin-bottom: 8px;
            font-weight: 600;
        }

        .download-btn {
            background: linear-gradient(45deg, #FF6B6B, #ee5a52);
            color: white;
            padding: 15px 30px;
            border: none;
            border-radius: 25px;
            cursor: pointer;
            font-size: 18px;
            margin: 10px;
            transition: all 0.3s ease;
            box-shadow: 0 4px 15px rgba(0,0,0,0.2);
        }

        .download-btn:hover:not(:disabled) {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(0,0,0,0.3);
        }

        .download-btn:disabled {
            background: #666;
            cursor: not-allowed;
            transform: none;
            opacity: 0.6;
        }

        .download-btn.downloaded {
            background: linear-gradient(45deg, #4CAF50, #45a049);
        }

        .progress-bar {
            width: 100%;
            height: 10px;
            background: rgba(255,255,255,0.2);
            border-radius: 5px;
            overflow: hidden;
            margin: 10px 0;
            display: none;
        }

        .progress-fill {
            height: 100%;
            background: linear-gradient(45deg, #4CAF50, #45a049);
            width: 0%;
            transition: width 0.3s ease;
        }

        @media (max-width: 768px) {
            .controls {
                grid-template-columns: 1fr;
            }
            
            .download-btn {
                display: block;
                margin: 10px auto;
                width: 80%;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>ğŸŒŸ å¢å¼·ç‰ˆå‹•æ…‹ç‰¹æ•ˆè¦†è“‹å™¨ âœ¨</h1>
        
        <div class="upload-area" id="uploadArea">
            <p style="font-size: 1.2em; margin-bottom: 20px;">æ‹–æ›³ç…§ç‰‡ã€GIF æˆ–å½±ç‰‡åˆ°é€™è£¡ï¼Œæˆ–é»æ“Šä¸Šå‚³</p>
            <button class="upload-btn" onclick="document.getElementById('fileInput').click()">
                ğŸ“ é¸æ“‡æª”æ¡ˆ
            </button>
            <input type="file" id="fileInput" accept="image/*,video/*,.gif">
            <div id="ffmpegStatus" style="margin-top:10px;font-size:12px;opacity:0.85"></div>
        </div>

        <div class="controls">
            <div class="control-group">
                <label for="effectType">ç‰¹æ•ˆé¡å‹</label>
                <select id="effectType">
                    <optgroup label="å¤©æ°£æ•ˆæœ">
                        <option value="snow">â„ï¸ ä¸‹é›ª</option>
                        <option value="rain">ğŸŒ§ï¸ ä¸‹é›¨</option>
                        <option value="storm">â›ˆï¸ æš´é¢¨é›¨</option>
                        <option value="lightning">âš¡ é–ƒé›»</option>
                    </optgroup>
                    <optgroup label="è‡ªç„¶æ•ˆæœ">
                        <option value="leaves">ğŸ‚ è½è‘‰</option>
                        <option value="sakura">ğŸŒ¸ æ«»èŠ±</option>
                        <option value="fireflies">âœ¨ è¢ç«èŸ²</option>
                        <option value="butterflies">ğŸ¦‹ è´è¶</option>
                    </optgroup>
                    <optgroup label="å¤¢å¹»æ•ˆæœ">
                        <option value="stars">â­ æ˜Ÿæ˜Ÿ</option>
                        <option value="bubbles">ğŸ«§ æ³¡æ³¡</option>
                        <option value="hearts">ğŸ’– æ„›å¿ƒ</option>
                        <option value="sparkles">âœ¨ é–ƒçˆ</option>
                    </optgroup>
                    <optgroup label="ç¯€æ…¶æ•ˆæœ">
                        <option value="fireworks" selected>ğŸ† ç…™ç«</option>
                        <option value="fireworks_big">ğŸ‡ ç…™ç«ï¼ˆå¤§å‹ï¼‰</option>
                        <option value="fireworks_heart">ğŸ’– ç…™ç«ï¼ˆæ„›å¿ƒï¼‰</option>
                    </optgroup>
                    <optgroup label="ç§‘æŠ€æ•ˆæœ">
                        <option value="matrix">ğŸ”¢ æ•¸å­—é›¨</option>
                        <option value="particles">âš›ï¸ ç²’å­æµ</option>
                        <option value="glitch">ğŸ“º æ•…éšœæ•ˆæœ</option>
                        <option value="neon">ğŸ’ éœ“è™¹</option>
                    </optgroup>
                    <optgroup label="é­”æ³•æ•ˆæœ">
                        <option value="magic">ğŸª„ é­”æ³•ç²’å­</option>
                        <option value="fairy">ğŸ§š ä»™å¥³å¡µ</option>
                        <option value="portal">ğŸŒ€ å‚³é€é–€</option>
                        <option value="runes">ğŸ”® ç¬¦æ–‡</option>
                    </optgroup>
                </select>
            </div>
            
            <div class="control-group">
                <label for="intensity">å¼·åº¦: <span id="intensityValue">50</span></label>
                <input type="range" id="intensity" min="10" max="200" value="50">
            </div>
            
            <div class="control-group">
                <label for="speed">é€Ÿåº¦: <span id="speedValue">2</span></label>
                <input type="range" id="speed" min="0.5" max="5" step="0.1" value="2">
            </div>
            
            <div class="control-group">
                <label for="size">å¤§å°: <span id="sizeValue">3</span></label>
                <input type="range" id="size" min="1" max="8" step="0.5" value="3">
            </div>

            <div class="control-group">
                <label for="colorMode">é¡è‰²æ¨¡å¼</label>
                <select id="colorMode">
                    <option value="default">é è¨­</option>
                    <option value="rainbow">å½©è™¹</option>
                    <option value="monochrome">å–®è‰²</option>
                    <option value="warm">æš–è‰²èª¿</option>
                    <option value="cool">å†·è‰²èª¿</option>
                </select>
            </div>

            <div class="control-group">
                <label for="blendMode">æ··åˆæ¨¡å¼</label>
                <select id="blendMode">
                    <option value="normal">æ­£å¸¸</option>
                    <option value="multiply">ç›¸ä¹˜</option>
                    <option value="screen">æ¿¾è‰²</option>
                    <option value="overlay">è¦†è“‹</option>
                    <option value="soft-light">æŸ”å…‰</option>
                    <option value="hard-light">å¼·å…‰</option>
                    <option value="difference">å·®ç•°</option>
                    <option value="exclusion">æ’é™¤</option>
                </select>
            </div>
            
            <div class="control-group">
                <label>å¿«é€Ÿè¨­å®š</label>
                <button class="upload-btn" id="lowLoadBtn">âš™ï¸ ä½è² è¼‰æ¨¡å¼</button>
            </div>
        </div>

        <div class="media-container" id="mediaContainer">
            <img id="mediaElement" style="display: none;">
            <video id="videoElement" style="display: none;" controls muted loop></video>
            <canvas id="effectCanvas"></canvas>
        </div>

        <div class="download-section" id="downloadSection">
            <div class="download-options">
                <h3 style="text-align: center; margin-bottom: 20px;">ğŸ’¾ ä¸‹è¼‰é¸é …</h3>
                
                <div class="option-group">
                    <label for="duration">å‹•ç•«æ™‚é•·: <span id="durationValue">5</span> ç§’</label>
                    <input type="range" id="duration" min="3" max="15" value="5" style="width: 100%;">
                </div>
                
                <div class="option-group">
                    <label for="fps">å¹€ç‡ (FPS)</label>
                    <select id="fps" style="width: 100%;">
                        <option value="15">15 FPS (æª”æ¡ˆè¼ƒå°)</option>
                        <option value="24" selected>24 FPS (æ¨™æº–)</option>
                        <option value="30">30 FPS (æµæš¢)</option>
                        <option value="60">60 FPS (è¶…æµæš¢)</option>
                    </select>
                </div>
                
                <div class="option-group">
                    <label for="quality">å“è³ªè¨­å®š</label>
                    <select id="quality" style="width: 100%;">
                        <option value="0.3">ä½å“è³ª (æª”æ¡ˆæœ€å°)</option>
                        <option value="0.6">ä¸­å“è³ª</option>
                        <option value="0.8" selected>é«˜å“è³ª</option>
                        <option value="1.0">æœ€é«˜å“è³ª</option>
                    </select>
                </div>
                
                <div class="progress-bar" id="progressBar">
                    <div class="progress-fill" id="progressFill"></div>
                </div>
                <div id="progressText" style="text-align: center; margin: 10px 0;"></div>
                
                <div style="text-align: center;">
                    <button class="download-btn" id="downloadGifBtn">ğŸï¸ ä¸‹è¼‰ GIF å‹•ç•«</button>
                    <button class="download-btn" id="downloadMp4Btn">ğŸ¬ ä¸‹è¼‰ WebM å½±ç‰‡</button>
                    <button class="download-btn" id="downloadImageBtn">ğŸ–¼ï¸ ä¸‹è¼‰éœæ…‹åœ–ç‰‡</button>
                </div>
            </div>
        </div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/gif.js/0.2.0/gif.js"></script>
    <script src="https://unpkg.com/@ffmpeg/ffmpeg@0.12.10/dist/ffmpeg.min.js"></script>
    <script>
        (function() {
            const originalGetContext = HTMLCanvasElement.prototype.getContext;
            HTMLCanvasElement.prototype.getContext = function(type, options) {
                if (type === '2d') {
                    const nextOptions = options && typeof options === 'object' ? {...options} : {};
                    if (!nextOptions.willReadFrequently) nextOptions.willReadFrequently = true;
                    return originalGetContext.call(this, type, nextOptions);
                }
                return originalGetContext.call(this, type, options);
            };
        })();
    </script>
    <script>
        class EnhancedEffectEngine {
            constructor() {
                this.canvas = document.getElementById('effectCanvas');
                this.ctx = this.canvas.getContext('2d', { willReadFrequently: true });
                this.particles = [];
                this.animationId = null;
                this.effectType = 'fireworks';
                this.intensity = 50;
                this.speed = 2;
                this.size = 3;
                this.colorMode = 'default';
                this.blendMode = 'normal';
                this.isImage = true;
                this.mediaElement = null;
                this.time = 0;
                
                this.lightningFlashes = [];
                this.magicTrails = [];
                this.runeRotations = [];
                this.fireworkSpawnTimer = 0;
                
                // æ–°å¢ï¼šä¸‹è¼‰ç‹€æ…‹è¿½è¹¤
                this.downloadStates = {
                    gif: false,
                    mp4: false,
                    image: false
                };
                
                this.ffmpegCoreBase = 'https://unpkg.com/@ffmpeg/core@0.12.10/dist/ffmpeg-core.js';
                this.setupEventListeners();
            }
            
            // æ–°å¢ï¼šé‡ç½®æ‰€æœ‰ä¸‹è¼‰ç‹€æ…‹
            resetDownloadStates() {
                this.downloadStates = {
                    gif: false,
                    mp4: false,
                    image: false
                };
                this.updateDownloadButtons();
            }
            
            // æ–°å¢ï¼šæ›´æ–°ä¸‹è¼‰æŒ‰éˆ•ç‹€æ…‹
            updateDownloadButtons() {
                const gifBtn = document.getElementById('downloadGifBtn');
                const mp4Btn = document.getElementById('downloadMp4Btn');
                const imageBtn = document.getElementById('downloadImageBtn');
                
                if (this.downloadStates.gif) {
                    gifBtn.textContent = 'âœ… GIF å·²ä¸‹è¼‰';
                    gifBtn.classList.add('downloaded');
                    gifBtn.disabled = true;
                } else {
                    gifBtn.textContent = 'ğŸï¸ ä¸‹è¼‰ GIF å‹•ç•«';
                    gifBtn.classList.remove('downloaded');
                    gifBtn.disabled = false;
                }
                
                if (this.downloadStates.mp4) {
                    mp4Btn.textContent = 'âœ… WebM å·²ä¸‹è¼‰';
                    mp4Btn.classList.add('downloaded');
                    mp4Btn.disabled = true;
                } else {
                    mp4Btn.textContent = 'ğŸ¬ ä¸‹è¼‰ WebM å½±ç‰‡';
                    mp4Btn.classList.remove('downloaded');
                    mp4Btn.disabled = false;
                }
                
                if (this.downloadStates.image) {
                    imageBtn.textContent = 'âœ… åœ–ç‰‡å·²ä¸‹è¼‰';
                    imageBtn.classList.add('downloaded');
                    imageBtn.disabled = true;
                } else {
                    imageBtn.textContent = 'ğŸ–¼ï¸ ä¸‹è¼‰éœæ…‹åœ–ç‰‡';
                    imageBtn.classList.remove('downloaded');
                    imageBtn.disabled = false;
                }
            }
            
            async loadFFmpegScript() {
                if (window.FFmpeg || window.createFFmpeg) return;
                const manualScript = (window.FFMPEG_SCRIPT_URL || (window.FFMPEG_BASE_URL && window.FFMPEG_BASE_URL + '/ffmpeg.min.js')) || null;
                const manualCore = (window.FFMPEG_CORE_URL || (window.FFMPEG_BASE_URL && window.FFMPEG_BASE_URL + '/ffmpeg-core.js')) || null;

                let inferredBase = '';
                try {
                    const parts = (location.pathname || '').split('/').filter(Boolean);
                    if (parts.length >= 1) {
                        inferredBase = `/${parts[0]}`;
                    }
                } catch(_) {}

                const candidates = [
                    ...(manualScript ? [{ script: manualScript, core: manualCore || manualScript.replace('ffmpeg.min.js', 'ffmpeg-core.js') }] : []),
                    {
                        script: 'https://unpkg.com/@ffmpeg/ffmpeg@0.12.10/dist/ffmpeg.min.js',
                        core: 'https://unpkg.com/@ffmpeg/core@0.12.10/dist/ffmpeg-core.js'
                    },
                    {
                        script: 'https://cdn.jsdelivr.net/npm/@ffmpeg/ffmpeg@0.12.10/dist/ffmpeg.min.js',
                        core: 'https://cdn.jsdelivr.net/npm/@ffmpeg/core@0.12.10/dist/ffmpeg-core.js'
                    },
                    { script: './libs/ffmpeg/ffmpeg.min.js', core: './libs/ffmpeg/ffmpeg-core.js' },
                    { script: 'libs/ffmpeg/ffmpeg.min.js', core: 'libs/ffmpeg/ffmpeg-core.js' },
                    ...(inferredBase ? [{ script: `${inferredBase}/libs/ffmpeg/ffmpeg.min.js`, core: `${inferredBase}/libs/ffmpeg/ffmpeg-core.js` }] : [])
                ];
                
                const tryLoad = (src) => new Promise((resolve, reject) => {
                    const s = document.createElement('script');
                    s.src = src;
                    s.async = true;
                    s.onload = () => resolve(true);
                    s.onerror = () => reject(new Error('Failed to load ' + src));
                    document.head.appendChild(s);
                });
                
                let lastError = null;
                for (const c of candidates) {
                    try {
                        await tryLoad(c.script);
                        this.ffmpegCoreBase = c.core;
                        this.updateFfmpegStatus(`FFmpeg ä¾†æºï¼š${c.script}`);
                        return;
                    } catch (e) {
                        lastError = e;
                        this.updateFfmpegStatus(`è¼‰å…¥å¤±æ•—ï¼š${c.script}`);
                    }
                }
                throw lastError || new Error('Failed to load ffmpeg script');
            }

            async ensureFFmpeg() {
                if (this.ffmpeg && this.ffmpeg.isLoaded) return;
                if (!window.FFmpeg && !window.createFFmpeg) {
                    await this.loadFFmpegScript();
                }
                const createFFmpeg = (window.FFmpeg && window.FFmpeg.createFFmpeg) || window.createFFmpeg;
                if (!createFFmpeg) throw new Error('FFmpeg library not loaded');
                this.ffmpeg = createFFmpeg({
                    log: false,
                    corePath: this.ffmpegCoreBase
                });
                try {
                    await this.ffmpeg.load();
                    this.updateFfmpegStatus(`FFmpeg core OKï¼š${this.ffmpegCoreBase}`);
                } catch (e) {
                    this.updateFfmpegStatus(`FFmpeg core è¼‰å…¥å¤±æ•—ï¼š${this.ffmpegCoreBase}`);
                    throw e;
                }
            }

            updateFfmpegStatus(text) {
                const el = document.getElementById('ffmpegStatus');
                if (!el) return;
                const now = new Date();
                const time = `${now.getHours().toString().padStart(2,'0')}:${now.getMinutes().toString().padStart(2,'0')}:${now.getSeconds().toString().padStart(2,'0')}`;
                const line = document.createElement('div');
                line.textContent = `[${time}] ${text}`;
                el.appendChild(line);
            }
            
            async convertGifToWebm(gifBlob) {
                await this.ensureFFmpeg();
                const data = new Uint8Array(await gifBlob.arrayBuffer());
                try { this.ffmpeg.FS('unlink', 'input.gif'); } catch(_) {}
                try { this.ffmpeg.FS('unlink', 'output.webm'); } catch(_) {}
                this.ffmpeg.FS('writeFile', 'input.gif', data);
                await this.ffmpeg.run(
                    '-i', 'input.gif',
                    '-c:v', 'libvpx',
                    '-b:v', '1.5M',
                    '-deadline', 'realtime',
                    '-pix_fmt', 'yuv420p',
                    '-an',
                    'output.webm'
                );
                const out = this.ffmpeg.FS('readFile', 'output.webm');
                return new Blob([out.buffer], { type: 'video/webm' });
            }
            
            setupEventListeners() {
                const fileInput = document.getElementById('fileInput');
                const uploadArea = document.getElementById('uploadArea');
                const effectType = document.getElementById('effectType');
                const intensity = document.getElementById('intensity');
                const speed = document.getElementById('speed');
                const size = document.getElementById('size');
                const colorMode = document.getElementById('colorMode');
                const blendMode = document.getElementById('blendMode');
                const downloadGifBtn = document.getElementById('downloadGifBtn');
                const downloadMp4Btn = document.getElementById('downloadMp4Btn');
                const downloadImageBtn = document.getElementById('downloadImageBtn');
                const duration = document.getElementById('duration');
                const lowLoadBtn = document.getElementById('lowLoadBtn');
                
                fileInput.addEventListener('change', (e) => this.handleFile(e.target.files[0]));
                
                uploadArea.addEventListener('dragover', (e) => {
                    e.preventDefault();
                    uploadArea.classList.add('dragover');
                });
                
                uploadArea.addEventListener('dragleave', () => {
                    uploadArea.classList.remove('dragover');
                });
                
                uploadArea.addEventListener('drop', (e) => {
                    e.preventDefault();
                    uploadArea.classList.remove('dragover');
                    this.handleFile(e.dataTransfer.files[0]);
                });
                
                // ä¿®æ”¹ï¼šåƒæ•¸è®Šæ›´æ™‚é‡ç½®ä¸‹è¼‰ç‹€æ…‹
                effectType.addEventListener('change', (e) => {
                    this.effectType = e.target.value;
                    this.initParticles();
                    this.resetDownloadStates();
                });
                
                intensity.addEventListener('input', (e) => {
                    this.intensity = parseInt(e.target.value);
                    document.getElementById('intensityValue').textContent = e.target.value;
                    this.initParticles();
                    this.resetDownloadStates();
                });
                
                speed.addEventListener('input', (e) => {
                    this.speed = parseFloat(e.target.value);
                    document.getElementById('speedValue').textContent = e.target.value;
                    this.resetDownloadStates();
                });
                
                size.addEventListener('input', (e) => {
                    this.size = parseFloat(e.target.value);
                    document.getElementById('sizeValue').textContent = e.target.value;
                    this.resetDownloadStates();
                });
                
                colorMode.addEventListener('change', (e) => {
                    this.colorMode = e.target.value;
                    this.resetDownloadStates();
                });
                
                blendMode.addEventListener('change', (e) => {
                    this.blendMode = e.target.value;
                    this.resetDownloadStates();
                });
                
                duration.addEventListener('input', (e) => {
                    document.getElementById('durationValue').textContent = e.target.value;
                    this.resetDownloadStates();
                });
                
                downloadGifBtn.addEventListener('click', () => this.downloadGif());
                downloadMp4Btn.addEventListener('click', () => this.downloadMp4());
                downloadImageBtn.addEventListener('click', () => this.downloadImage());

                if (lowLoadBtn) {
                    lowLoadBtn.addEventListener('click', () => {
                        intensity.value = 30; this.intensity = 30; document.getElementById('intensityValue').textContent = '30';
                        size.value = 3; this.size = 3; document.getElementById('sizeValue').textContent = '3';
                        speed.value = 2; this.speed = 2; document.getElementById('speedValue').textContent = '2';
                        colorMode.value = 'default'; this.colorMode = 'default';
                        blendMode.value = 'normal'; this.blendMode = 'normal';
                        
                        const fpsSel = document.getElementById('fps'); if (fpsSel) fpsSel.value = '15';
                        duration.value = 3; document.getElementById('durationValue').textContent = '3';
                        const qualitySel = document.getElementById('quality'); if (qualitySel) qualitySel.value = '0.6';
                        
                        this.initParticles();
                        this.resetDownloadStates();
                    });
                }
            }
            
            async handleFile(file) {
                if (!file) return;
                
                const mediaContainer = document.getElementById('mediaContainer');
                const imgElement = document.getElementById('mediaElement');
                const videoElement = document.getElementById('videoElement');
                const downloadSection = document.getElementById('downloadSection');
                
                downloadSection.style.display = 'block';
                this.resetDownloadStates(); // æ–°æª”æ¡ˆä¸Šå‚³æ™‚é‡ç½®

                if (file.type === 'image/gif') {
                    try {
                        this.setButtonsState(true);
                        this.showProgress('æ­£åœ¨å°‡ GIF è½‰ç‚ºå½±ç‰‡ä»¥ä¿ç•™å‹•æ…‹...');
                        const webmBlob = await this.convertGifToWebm(file);
                        const url = URL.createObjectURL(webmBlob);
                        this.isImage = false;
                        this.mediaElement = videoElement;
                        videoElement.src = url;
                        videoElement.style.display = 'block';
                        imgElement.style.display = 'none';
                        videoElement.onloadedmetadata = () => {
                            this.setupCanvas();
                            this.initParticles();
                            this.animate();
                            videoElement.play();
                        };
                    } catch (e) {
                        console.error('GIF è½‰ WebM å¤±æ•—ï¼š', e);
                        document.getElementById('progressText').textContent = 'âŒ GIF è½‰æ›å¤±æ•—ï¼Œå°‡ä»¥éœæ…‹åœ–ç‰‡é¡¯ç¤ºã€‚å¯å˜—è©¦ä½è² è¼‰æ¨¡å¼æˆ–æ”¹å‚³å½±ç‰‡ã€‚';
                    } finally {
                        this.hideProgress();
                        this.setButtonsState(false);
                    }
                    mediaContainer.style.display = 'block';
                    return;
                }
                
                const reader = new FileReader();
                reader.onload = (e) => {
                    if (file.type.startsWith('image/')) {
                        this.isImage = true;
                        this.mediaElement = imgElement;
                        imgElement.src = e.target.result;
                        imgElement.style.display = 'block';
                        videoElement.style.display = 'none';
                        videoElement.pause();
                        
                        imgElement.onload = () => {
                            this.setupCanvas();
                            this.initParticles();
                            this.animate();
                        };
                    } else if (file.type.startsWith('video/')) {
                        this.isImage = false;
                        this.mediaElement = videoElement;
                        videoElement.src = e.target.result;
                        videoElement.style.display = 'block';
                        imgElement.style.display = 'none';
                        
                        videoElement.onloadedmetadata = () => {
                            this.setupCanvas();
                            this.initParticles();
                            this.animate();
                            videoElement.play();
                        };
                    }
                };
                reader.readAsDataURL(file);
                mediaContainer.style.display = 'block';
            }
            
            setupCanvas() {
                this.mediaElement = this.isImage ? 
                    document.getElementById('mediaElement') : 
                    document.getElementById('videoElement');
                
                const container = document.getElementById('mediaContainer');
                const targetWidth = (container && container.clientWidth) || this.mediaElement.offsetWidth || 300;
                const targetHeight = (container && container.clientHeight) || this.mediaElement.offsetHeight || 300;
                
                this.canvas.width = targetWidth;
                this.canvas.height = targetHeight;
            }
            
            getParticleColor(particle, baseColor = null) {
                const { colorMode } = this;
                let color = baseColor || 'white';
                
                switch (colorMode) {
                    case 'rainbow':
                        const hue = (particle.hue || 0) + this.time * 0.5;
                        color = `hsl(${hue % 360}, 70%, 60%)`;
                        break;
                    case 'monochrome':
                        const gray = Math.random() * 100 + 50;
                        color = `hsl(0, 0%, ${gray}%)`;
                        break;
                    case 'warm':
                        const warmHue = Math.random() * 60 + 300;
                        color = `hsl(${warmHue}, 70%, 60%)`;
                        break;
                    case 'cool':
                        const coolHue = Math.random() * 120 + 180;
                        color = `hsl(${coolHue}, 70%, 60%)`;
                        break;
                }
                
                return color;
            }
            
            createRocket(explosionStyle = 'default') {
                return {
                    kind: 'rocket',
                    x: this.canvas.width * (0.1 + Math.random() * 0.8),
                    y: this.canvas.height + 50,
                    vx: (Math.random() - 0.5) * 0.8,
                    vy: - (Math.random() * (2 + this.speed) * 0.8 + 4),
                    size: Math.random() * 1.5 + 1.5,
                    opacity: 1,
                    color: `hsl(${Math.floor(Math.random() * 360)}, 80%, 60%)`,
                    targetY: this.canvas.height * (0.1 + Math.random() * 0.4),
                    trail: [],
                    explosionStyle: explosionStyle
                };
            }

            createSpark(x, y, color, angle, velocity, life, size) {
                return {
                    kind: 'spark',
                    x: x,
                    y: y,
                    vx: Math.cos(angle) * velocity,
                    vy: Math.sin(angle) * velocity,
                    size: size,
                    opacity: 1,
                    color: color,
                    life: life,
                    maxLife: life
                };
            }

            createExplosion(rocket) {
                const sparks = [];
                const numSparks = rocket.explosionStyle === 'big' ? Math.floor(this.intensity * 0.5) + 50 : Math.floor(this.intensity * 0.3) + 30;
                const baseVelocity = 3 + (this.speed * 0.5);
                const sparkColor = rocket.color;

                if (rocket.explosionStyle === 'heart') {
                    for (let i = 0; i < numSparks; i++) {
                        const t = i / numSparks * Math.PI * 2;
                        let x = 16 * Math.pow(Math.sin(t), 3);
                        let y = -(13 * Math.cos(t) - 5 * Math.cos(2 * t) - 2 * Math.cos(3 * t) - Math.cos(4 * t));
                        const angle = Math.atan2(y, x);
                        const distance = Math.hypot(x, y);
                        const velocityScale = Math.random() * 0.5 + 0.5;
                        const velocity = baseVelocity * 0.15 + (distance * 0.05);
                        sparks.push(this.createSpark(rocket.x, rocket.y, sparkColor, angle, velocity * velocityScale, Math.random() * 40 + 60, Math.random() * 1.5 + 1));
                    }
                } else {
                    for (let i = 0; i < numSparks; i++) {
                        const angle = Math.random() * Math.PI * 2;
                        const velocity = baseVelocity * (Math.random() * 0.5 + 0.5);
                        const life = Math.random() * 50 + 70;
                        const size = Math.random() * 1.5 + 1;
                        sparks.push(this.createSpark(rocket.x, rocket.y, sparkColor, angle, velocity, life, size));
                    }
                }
                this.particles.push(...sparks);
            }
            
            initParticles() {
                this.particles = [];
                this.lightningFlashes = [];
                this.magicTrails = [];
                this.runeRotations = [];
                this.fireworkSpawnTimer = 0;
                
                let explosionStyle = 'default';
                if (this.effectType === 'fireworks_big') explosionStyle = 'big';
                if (this.effectType === 'fireworks_heart') explosionStyle = 'heart';
                
                if (this.effectType === 'fireworks') {
                    this.fireworkSpawnTimer = 1;
                } else if (this.effectType.startsWith('fireworks')) {
                    const rocketCount = Math.max(3, Math.floor(this.intensity / 5));
                    for (let i = 0; i < rocketCount; i++) {
                        this.particles.push(this.createRocket(explosionStyle));
                    }
                } else {
                    for (let i = 0; i < this.intensity; i++) {
                        this.particles.push(this.createParticle());
                    }
                }
                
                if (this.effectType === 'runes') {
                    for (let i = 0; i < this.intensity; i++) {
                        this.runeRotations.push(Math.random() * Math.PI * 2);
                    }
                }
            }
            
            createParticle() {
                const particle = {
                    x: Math.random() * this.canvas.width,
                    y: Math.random() * this.canvas.height - this.canvas.height,
                    vx: 0,
                    vy: 0,
                    size: Math.random() * this.size + 1,
                    opacity: Math.random() * 0.8 + 0.2,
                    angle: 0,
                    hue: Math.random() * 360,
                    life: 1,
                    maxLife: 1,
                    trail: [],
                    kind: 'default'
                };
                
                switch (this.effectType) {
                    case 'snow':
                        particle.vx = (Math.random() - 0.5) * 0.5;
                        particle.vy = Math.random() * this.speed + 0.5;
                        break;
                    case 'rain':
                        particle.vx = Math.random() * 2 - 1;
                        particle.vy = Math.random() * this.speed + 3;
                        particle.size = Math.random() * 2 + 1;
                        break;
                    case 'leaves':
                        particle.vx = (Math.random() - 0.5) * 0.5;
                        particle.vy = Math.random() * this.speed + 1;
                        particle.angle = Math.random() * Math.PI * 2;
                        break;
                    case 'hearts':
                        particle.vx = (Math.random() - 0.5) * 1;
                        particle.vy = Math.random() * this.speed + 0.5;
                        particle.pulse = Math.random() * Math.PI * 2;
                        particle.size = Math.random() * 4 + 4;
                        break;
                }
                return particle;
            }
            
            updateParticle(particle, index) {
                particle.x += particle.vx;
                particle.y += particle.vy;

                switch (this.effectType) {
                    case 'fireworks_big':
                    case 'fireworks_heart':
                        if (particle.kind === 'rocket') {
                            particle.vy += 0.08;
                            particle.trail.push({ x: particle.x, y: particle.y, life: 1, color: particle.color });
                            particle.trail = particle.trail.filter(t => (t.life -= 0.05) > 0);
                            if (particle.y <= particle.targetY || particle.vy > 1) {
                                this.createExplosion(particle);
                                const newRocket = this.createRocket(particle.explosionStyle);
                                Object.assign(particle, newRocket);
                                return;
                            }
                        } else if (particle.kind === 'spark') {
                            particle.vy += 0.04;
                            particle.vx *= 0.98;
                            particle.vy *= 0.98;
                            particle.life -= 1;
                            particle.opacity = particle.life / particle.maxLife;
                            if (particle.life <= 0) {
                                this.particles.splice(index, 1);
                                return;
                            }
                        }
                        break;

                    case 'fireworks':
                        if (particle.kind === 'spark') {
                            particle.vy += 0.04;
                            particle.vx *= 0.98;
                            particle.vy *= 0.98;
                            particle.life -= 1;
                            particle.opacity = particle.life / particle.maxLife;
                            if (particle.life <= 0) {
                                this.particles.splice(index, 1);
                                return;
                            }
                        } else {
                            this.particles.splice(index, 1);
                            return;
                        }
                        break;

                    case 'leaves':
                        particle.angle += 0.02;
                        particle.x += Math.sin(particle.angle) * 0.5;
                        break;
                        
                    case 'hearts':
                        particle.pulse += 0.1;
                        break;
                }
                
                if (!this.effectType.startsWith('fireworks') && particle.kind !== 'spark') {
                    if (particle.y > this.canvas.height + 50 || particle.x < -50 || particle.x > this.canvas.width + 50) {
                        Object.assign(particle, this.createParticle());
                        particle.y = Math.random() * 50 - 50;
                    }
                }
            }
            
            drawParticle(particle, index) {
                this.ctx.globalAlpha = particle.opacity;
                this.ctx.fillStyle = this.getParticleColor(particle);
                this.ctx.strokeStyle = this.getParticleColor(particle);

                if (this.effectType.startsWith('fireworks')) {
                    if (particle.kind === 'rocket') {
                        this.ctx.globalAlpha = 1;
                        this.ctx.fillStyle = particle.color;
                        this.ctx.beginPath();
                        this.ctx.arc(particle.x, particle.y, particle.size, 0, Math.PI * 2);
                        this.ctx.fill();
                        
                        this.ctx.lineWidth = particle.size * 0.75;
                        this.ctx.lineCap = 'round';
                        for (let i = 0; i < particle.trail.length; i++) {
                            const t = particle.trail[i];
                            const trailColor = t.color.replace('80%', '95%').replace('60%', '75%');
                            this.ctx.globalAlpha = t.life * 0.6;
                            this.ctx.strokeStyle = trailColor;
                            if (i > 0) {
                                this.ctx.beginPath();
                                this.ctx.moveTo(particle.trail[i-1].x, particle.trail[i-1].y);
                                this.ctx.lineTo(t.x, t.y);
                                this.ctx.stroke();
                            }
                        }
                    } else if (particle.kind === 'spark') {
                        this.ctx.globalAlpha = particle.opacity * 0.8;
                        this.ctx.fillStyle = particle.color;
                        this.ctx.shadowBlur = 5;
                        this.ctx.shadowColor = particle.color;
                        this.ctx.beginPath();
                        this.ctx.arc(particle.x, particle.y, particle.size, 0, Math.PI * 2);
                        this.ctx.fill();
                        this.ctx.shadowBlur = 0;
                    }
                    this.ctx.globalAlpha = 1;
                    return;
                }
                
                switch (this.effectType) {
                    case 'snow':
                    case 'rain':
                        this.ctx.beginPath();
                        this.ctx.arc(particle.x, particle.y, particle.size, 0, Math.PI * 2);
                        this.ctx.fill();
                        break;
                    case 'leaves':
                        this.ctx.save();
                        this.ctx.translate(particle.x, particle.y);
                        this.ctx.rotate(particle.angle);
                        this.ctx.fillRect(-particle.size, -particle.size * 0.5, particle.size * 2, particle.size);
                        this.ctx.restore();
                        break;
                    case 'hearts':
                        this.ctx.fillStyle = this.getParticleColor(particle, 'rgb(255, 100, 150)');
                        this.ctx.globalAlpha = particle.opacity;
                        this.ctx.save();
                        this.ctx.translate(particle.x, particle.y);
                        const scale = particle.size * (1 + Math.sin(particle.pulse) * 0.1) * 0.1;
                        this.ctx.scale(scale, scale);
                        this.ctx.beginPath();
                        this.ctx.moveTo(0, -5);
                        this.ctx.bezierCurveTo(5, -15, 20, -10, 0, 10);
                        this.ctx.bezierCurveTo(-20, -10, -5, -15, 0, -5);
                        this.ctx.closePath();
                        this.ctx.fill();
                        this.ctx.restore();
                        break;
                }
                
                this.ctx.globalAlpha = 1;
            }
            
            drawMedia() {
                if (this.mediaElement) {
                    const { width, height } = this.canvas;
                    this.ctx.drawImage(this.mediaElement, 0, 0, width, height);
                }
            }

            animate = (timestamp) => {
                if (!this.mediaElement) return;
                this.time += 0.01;
                
                this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
                this.drawMedia();
                this.ctx.globalCompositeOperation = this.blendMode;

                if (this.effectType === 'fireworks') {
                    this.fireworkSpawnTimer -= 1;
                    const maxSpawnInterval = 100 - Math.min(80, this.intensity * 0.4);
                    if (this.fireworkSpawnTimer <= 0) {
                        const explosionY = this.canvas.height * (0.1 + Math.random() * 0.3);
                        const rocketPlaceholder = {
                            kind: 'rocket',
                            x: this.canvas.width * (0.1 + Math.random() * 0.8),
                            y: explosionY,
                            color: `hsl(${Math.floor(Math.random() * 360)}, 80%, 60%)`,
                            explosionStyle: 'default'
                        };
                        this.createExplosion(rocketPlaceholder);
                        this.fireworkSpawnTimer = Math.max(20, Math.random() * maxSpawnInterval);
                    }
                }

                for (let i = this.particles.length - 1; i >= 0; i--) {
                    const particle = this.particles[i];
                    this.updateParticle(particle, i);
                    this.drawParticle(particle, i);
                }
                
                this.ctx.globalCompositeOperation = 'normal';
                this.animationId = requestAnimationFrame(this.animate);
            }
            
            setButtonsState(disabled) {
                const buttons = ['downloadGifBtn', 'downloadMp4Btn', 'downloadImageBtn', 'lowLoadBtn'];
                buttons.forEach(id => {
                    const btn = document.getElementById(id);
                    if (btn) btn.disabled = disabled;
                });
            }
            
            showProgress(text) {
                const bar = document.getElementById('progressBar');
                const fill = document.getElementById('progressFill');
                const txt = document.getElementById('progressText');
                if (bar && fill && txt) {
                    bar.style.display = 'block';
                    fill.style.width = '0%';
                    txt.textContent = text || '';
                }
            }
            
            updateProgress(percent, text) {
                const fill = document.getElementById('progressFill');
                const txt = document.getElementById('progressText');
                if (fill) fill.style.width = `${Math.max(0, Math.min(100, percent))}%`;
                if (txt && text !== undefined) txt.textContent = text;
            }
            
            hideProgress() {
                const bar = document.getElementById('progressBar');
                if (bar) bar.style.display = 'none';
            }
            
            async downloadGif() {
                if (this.downloadStates.gif) return; // é˜²æ­¢é‡è¤‡ä¸‹è¼‰
                
                if (!window.GIF) {
                    document.getElementById('progressText').textContent = 'âŒ GIF å‡½å¼åº«æœªè¼‰å…¥ï¼Œç„¡æ³•ä¸‹è¼‰ GIFã€‚';
                    return;
                }
                if (!this.mediaElement) {
                    document.getElementById('progressText').textContent = 'âŒ è«‹å…ˆä¸Šå‚³åœ–ç‰‡æˆ–å½±ç‰‡ã€‚';
                    return;
                }
                
                try {
                    this.setButtonsState(true);
                    const durationInSeconds = parseFloat(document.getElementById('duration').value);
                    const fps = parseInt(document.getElementById('fps').value);
                    const numFrames = Math.floor(durationInSeconds * fps);
                    const delay = 1000 / fps;
                    const quality = Math.floor(100 - parseFloat(document.getElementById('quality').value) * 100);

                    this.showProgress(`é–‹å§‹ç”Ÿæˆ GIF (${numFrames} å¹€)...`);
                    
                    const gif = new GIF({
                        workers: 2,
                        quality: quality,
                        width: this.canvas.width,
                        height: this.canvas.height
                    });

                    const startTime = this.time;
                    const tempEngine = new EnhancedEffectEngine();
                    Object.assign(tempEngine, this);
                    tempEngine.initParticles();
                    
                    for (let i = 0; i < numFrames; i++) {
                        tempEngine.time = startTime + (i / fps);
                        tempEngine.ctx.clearRect(0, 0, tempEngine.canvas.width, tempEngine.canvas.height);
                        tempEngine.drawMedia();
                        tempEngine.ctx.globalCompositeOperation = tempEngine.blendMode;
                        
                        if (tempEngine.effectType === 'fireworks') {
                            tempEngine.fireworkSpawnTimer -= 1;
                            const maxSpawnInterval = 100 - Math.min(80, tempEngine.intensity * 0.4);
                            if (tempEngine.fireworkSpawnTimer <= 0) {
                                const explosionY = tempEngine.canvas.height * (0.1 + Math.random() * 0.3);
                                const rocketPlaceholder = {
                                    kind: 'rocket',
                                    x: tempEngine.canvas.width * (0.1 + Math.random() * 0.8),
                                    y: explosionY,
                                    color: `hsl(${Math.floor(Math.random() * 360)}, 80%, 60%)`,
                                    explosionStyle: 'default'
                                };
                                tempEngine.createExplosion(rocketPlaceholder);
                                tempEngine.fireworkSpawnTimer = Math.max(20, Math.random() * maxSpawnInterval);
                            }
                        }

                        for (let j = tempEngine.particles.length - 1; j >= 0; j--) {
                            const particle = tempEngine.particles[j];
                            tempEngine.updateParticle(particle, j);
                            tempEngine.drawParticle(particle, j);
                        }
                        tempEngine.ctx.globalCompositeOperation = 'normal';
                        gif.addFrame(tempEngine.ctx, { copy: true, delay: delay });
                        this.updateProgress((i + 1) / numFrames * 95, `ç”Ÿæˆä¸­... ${i + 1} / ${numFrames} å¹€`);
                        await new Promise(resolve => setTimeout(resolve, 0));
                    }

                    gif.on('finished', (blob) => {
                        const url = URL.createObjectURL(blob);
                        const a = document.createElement('a');
                        a.href = url;
                        a.download = `animated_effect_${Date.now()}.gif`;
                        document.body.appendChild(a);
                        a.click();
                        document.body.removeChild(a);
                        
                        this.downloadStates.gif = true; // æ¨™è¨˜å·²ä¸‹è¼‰
                        this.updateDownloadButtons();
                        this.hideProgress();
                        this.setButtonsState(false);
                        document.getElementById('progressText').textContent = 'âœ… GIF å‹•ç•«ä¸‹è¼‰å®Œæˆï¼';
                    });

                    gif.on('progress', (p) => {
                        this.updateProgress(95 + p * 5, `ç·¨ç¢¼ä¸­... ${Math.round(p * 100)}%`);
                    });

                    gif.render();
                    
                } catch (e) {
                    this.hideProgress();
                    this.setButtonsState(false);
                    console.error('GIF ä¸‹è¼‰å¤±æ•—:', e);
                    document.getElementById('progressText').textContent = 'âŒ GIF ä¸‹è¼‰å¤±æ•—ã€‚è«‹å˜—è©¦é™ä½ FPSã€ç¸®çŸ­æ™‚é•·æˆ–æ”¹ä¸‹è¼‰ WebMã€‚';
                }
            }
            
            async downloadMp4() {
                if (this.downloadStates.mp4) return; // é˜²æ­¢é‡è¤‡ä¸‹è¼‰
                
                if (!window.MediaRecorder) {
                    document.getElementById('progressText').textContent = 'âŒ æ‚¨çš„ç€è¦½å™¨ä¸æ”¯æ´ MediaRecorder APIï¼Œç„¡æ³•éŒ„è£½ WebM å½±ç‰‡ã€‚';
                    return;
                }
                if (!this.mediaElement) {
                    document.getElementById('progressText').textContent = 'âŒ è«‹å…ˆä¸Šå‚³åœ–ç‰‡æˆ–å½±ç‰‡ã€‚';
                    return;
                }

                try {
                    this.setButtonsState(true);
                    const durationInSeconds = parseFloat(document.getElementById('duration').value);
                    const fps = parseInt(document.getElementById('fps').value);
                    const quality = parseFloat(document.getElementById('quality').value);
                    const frameRate = fps;
                    const mimeType = 'video/webm; codecs=vp8';

                    this.showProgress('é–‹å§‹éŒ„è£½ WebM å½±ç‰‡...');

                    if (!this.animationId) {
                         this.animate();
                    }
                    
                    const stream = this.canvas.captureStream(frameRate);
                    const recorder = new MediaRecorder(stream, { mimeType: mimeType, videoBitsPerSecond: 5000000 * quality });

                    const chunks = [];
                    recorder.ondataavailable = (e) => {
                        if (e.data.size > 0) {
                            chunks.push(e.data);
                        }
                    };

                    const recordDurationMs = durationInSeconds * 1000;
                    
                    recorder.onstop = () => {
                        this.hideProgress();
                        this.setButtonsState(false);
                        
                        if (chunks.length === 0) {
                            document.getElementById('progressText').textContent = 'âŒ éŒ„è£½å¤±æ•—ï¼šæœªæ•ç²åˆ°å½±ç‰‡æ•¸æ“šã€‚';
                            return;
                        }
                        
                        const blob = new Blob(chunks, { type: mimeType });
                        const url = URL.createObjectURL(blob);
                        const a = document.createElement('a');
                        a.href = url;
                        a.download = `video_effect_${Date.now()}.webm`;
                        document.body.appendChild(a);
                        a.click();
                        document.body.removeChild(a);
                        
                        this.downloadStates.mp4 = true; // æ¨™è¨˜å·²ä¸‹è¼‰
                        this.updateDownloadButtons();
                        document.getElementById('progressText').textContent = 'âœ… WebM å½±ç‰‡ä¸‹è¼‰å®Œæˆï¼';
                        stream.getTracks().forEach(track => track.stop());
                    };

                    recorder.onerror = (e) => {
                         this.hideProgress();
                         this.setButtonsState(false);
                         console.error('MediaRecorder éŒ¯èª¤:', e);
                         document.getElementById('progressText').textContent = 'âŒ WebM éŒ„è£½å¤±æ•—ã€‚è©³æƒ…è«‹çœ‹ Consoleã€‚';
                    };

                    recorder.start();

                    const startTime = Date.now();
                    const interval = setInterval(() => {
                        const elapsed = Date.now() - startTime;
                        const percent = (elapsed / recordDurationMs) * 100;
                        this.updateProgress(percent, `éŒ„è£½ä¸­... ${Math.round(percent)}%`);
                        
                        if (elapsed >= recordDurationMs) {
                            clearInterval(interval);
                            if (recorder.state === 'recording') {
                                recorder.stop();
                                this.updateProgress(100, 'éŒ„è£½å®Œæˆï¼Œæ­£åœ¨å°è£æª”æ¡ˆ...');
                            }
                        }
                    }, 500);

                } catch (e) {
                    this.hideProgress();
                    this.setButtonsState(false);
                    console.error('WebM ä¸‹è¼‰å¤±æ•—:', e);
                    document.getElementById('progressText').textContent = 'âŒ WebM éŒ„è£½å¤±æ•—ã€‚è«‹ç¢ºèªæ‚¨çš„ç€è¦½å™¨æ˜¯å¦æ”¯æ´æˆ–å˜—è©¦å…¶ä»–ç·¨ç¢¼ã€‚';
                }
            }

            async downloadImage() {
                if (this.downloadStates.image) return; // é˜²æ­¢é‡è¤‡ä¸‹è¼‰
                
                if (!this.mediaElement) {
                    document.getElementById('progressText').textContent = 'âŒ è«‹å…ˆä¸Šå‚³åœ–ç‰‡æˆ–å½±ç‰‡ã€‚';
                    return;
                }
                
                try {
                    this.setButtonsState(true);
                    this.showProgress('æ­£åœ¨ç”Ÿæˆéœæ…‹åœ–ç‰‡...');

                    this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
                    this.drawMedia();
                    this.ctx.globalCompositeOperation = this.blendMode;
                    for (let j = 0; j < this.particles.length; j++) {
                        this.drawParticle(this.particles[j], j);
                    }
                    this.ctx.globalCompositeOperation = 'normal';

                    const quality = parseFloat(document.getElementById('quality').value);
                    const mimeType = 'image/png';
                    
                    const url = this.canvas.toDataURL(mimeType, quality);
                    const a = document.createElement('a');
                    a.href = url;
                    a.download = `static_effect_${Date.now()}.png`;
                    document.body.appendChild(a);
                    a.click();
                    document.body.removeChild(a);
                    
                    this.downloadStates.image = true; // æ¨™è¨˜å·²ä¸‹è¼‰
                    this.updateDownloadButtons();
                    this.hideProgress();
                    this.setButtonsState(false);
                    document.getElementById('progressText').textContent = 'âœ… éœæ…‹åœ–ç‰‡ä¸‹è¼‰å®Œæˆï¼';
                } catch(e) {
                    this.hideProgress();
                    this.setButtonsState(false);
                    console.error('åœ–ç‰‡ä¸‹è¼‰å¤±æ•—:', e);
                    document.getElementById('progressText').textContent = 'âŒ åœ–ç‰‡ä¸‹è¼‰å¤±æ•—ã€‚è©³æƒ…è«‹çœ‹ Consoleã€‚';
                }
            }
        }
        
        window.addEventListener('load', () => {
            try {
                window.__engine = new EnhancedEffectEngine();
            } catch (e) {
                console.error('åˆå§‹åŒ–å¤±æ•—:', e);
            }
        });
    </script>
</body>
</html>
                
