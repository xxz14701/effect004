<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>增強版動態特效覆蓋器</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            background: linear-gradient(135deg, #1e3c72 0%, #2a5298 100%);
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            min-height: 100vh;
            color: white;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
        }

        h1 {
            text-align: center;
            margin-bottom: 30px;
            font-size: 2.5em;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.3);
            background: linear-gradient(45deg, #ff6b6b, #4ecdc4, #45b7d1);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }

        .upload-area {
            border: 3px dashed rgba(255,255,255,0.3);
            border-radius: 15px;
            padding: 40px;
            text-align: center;
            margin-bottom: 30px;
            transition: all 0.3s ease;
            background: rgba(255,255,255,0.1);
            backdrop-filter: blur(10px);
        }

        .upload-area:hover {
            border-color: rgba(255,255,255,0.6);
            background: rgba(255,255,255,0.15);
        }

        .upload-area.dragover {
            border-color: #4CAF50;
            background: rgba(76, 175, 80, 0.2);
        }

        input[type="file"] {
            display: none;
        }

        .upload-btn {
            background: linear-gradient(45deg, #4CAF50, #45a049);
            color: white;
            padding: 15px 30px;
            border: none;
            border-radius: 25px;
            cursor: pointer;
            font-size: 18px;
            transition: all 0.3s ease;
            box-shadow: 0 4px 15px rgba(0,0,0,0.2);
        }

        .upload-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(0,0,0,0.3);
        }

        .controls {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 20px;
            margin-bottom: 30px;
            background: rgba(255,255,255,0.1);
            padding: 20px;
            border-radius: 15px;
            backdrop-filter: blur(10px);
        }

        .control-group {
            min-width: 200px;
        }

        .control-group label {
            display: block;
            margin-bottom: 8px;
            font-weight: 600;
        }

        select, input[type="range"] {
            width: 100%;
            padding: 10px;
            border: none;
            border-radius: 8px;
            background: rgba(255,255,255,0.2);
            color: white;
            font-size: 16px;
        }

        select {
            cursor: pointer;
        }

        select option {
            background: #2a5298;
            color: white;
        }

        input[type="range"] {
            padding: 5px;
            background: rgba(255,255,255,0.1);
        }

        .media-container {
            position: relative;
            max-width: 100%;
            margin: 0 auto;
            border-radius: 15px;
            overflow: hidden;
            box-shadow: 0 10px 30px rgba(0,0,0,0.3);
            display: none;
            width: 300px;
            height: 300px;
        }

        #mediaElement {
            width: 100%;
            height: 100%;
            display: block;
            object-fit: contain;
        }

        #videoElement {
            width: 100%;
            height: 100%;
            display: block;
            object-fit: contain;
        }

        #effectCanvas {
            position: absolute;
            top: 0;
            left: 0;
            pointer-events: none;
            width: 100%;
            height: 100%;
        }

        .download-section {
            display: none;
            text-align: center;
            margin: 20px 0;
        }

        .download-options {
            background: rgba(255,255,255,0.1);
            padding: 20px;
            border-radius: 15px;
            margin: 20px 0;
            backdrop-filter: blur(10px);
        }

        .option-group {
            margin: 15px 0;
            text-align: left;
        }

        .option-group label {
            display: block;
            margin-bottom: 8px;
            font-weight: 600;
        }

        .download-btn {
            background: linear-gradient(45deg, #FF6B6B, #ee5a52);
            color: white;
            padding: 15px 30px;
            border: none;
            border-radius: 25px;
            cursor: pointer;
            font-size: 18px;
            margin: 10px;
            transition: all 0.3s ease;
            box-shadow: 0 4px 15px rgba(0,0,0,0.2);
        }

        .download-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(0,0,0,0.3);
        }

        .download-btn:disabled {
            background: #666;
            cursor: not-allowed;
            transform: none;
        }

        .progress-bar {
            width: 100%;
            height: 10px;
            background: rgba(255,255,255,0.2);
            border-radius: 5px;
            overflow: hidden;
            margin: 10px 0;
            display: none;
        }

        .progress-fill {
            height: 100%;
            background: linear-gradient(45deg, #4CAF50, #45a049);
            width: 0%;
            transition: width 0.3s ease;
        }

        .effect-info {
            background: rgba(255,255,255,0.1);
            padding: 15px;
            border-radius: 10px;
            margin-top: 20px;
            backdrop-filter: blur(10px);
        }

        .effect-categories {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
            margin-bottom: 20px;
        }

        .category-section {
            background: rgba(255,255,255,0.05);
            padding: 15px;
            border-radius: 10px;
            border-left: 4px solid #4CAF50;
        }

        .category-title {
            font-weight: bold;
            margin-bottom: 10px;
            color: #4CAF50;
        }

        @media (max-width: 768px) {
            .controls {
                grid-template-columns: 1fr;
            }
            
            .download-btn {
                display: block;
                margin: 10px auto;
                width: 80%;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>🌟 增強版動態特效覆蓋器 ✨</h1>
        
        <div class="upload-area" id="uploadArea">
            <p style="font-size: 1.2em; margin-bottom: 20px;">拖曳照片或影片到這裡，或點擊上傳</p>
            <button class="upload-btn" onclick="document.getElementById('fileInput').click()">
                📁 選擇檔案
            </button>
            <input type="file" id="fileInput" accept="image/*,video/*">
        </div>

        <div class="controls">
            <div class="control-group">
                <label for="effectType">特效類型</label>
                <select id="effectType">
                    <optgroup label="天氣效果">
                        <option value="snow">❄️ 下雪</option>
                        <option value="rain">🌧️ 下雨</option>
                        <option value="storm">⛈️ 暴風雨</option>
                        <option value="lightning">⚡ 閃電</option>
                    </optgroup>
                    <optgroup label="自然效果">
                        <option value="leaves">🍂 落葉</option>
                        <option value="sakura">🌸 櫻花</option>
                        <option value="fireflies">✨ 螢火蟲</option>
                        <option value="butterflies">🦋 蝴蝶</option>
                    </optgroup>
                    <optgroup label="夢幻效果">
                        <option value="stars">⭐ 星星</option>
                        <option value="bubbles">🫧 泡泡</option>
                        <option value="hearts">💖 愛心</option>
                        <option value="sparkles">✨ 閃爍</option>
                    </optgroup>
                    <optgroup label="節慶效果">
                        <option value="fireworks" selected>🎆 煙火</option>
                        <option value="fireworks_big">🎇 煙火（大型）</option>
                        <option value="fireworks_heart">💖 煙火（愛心）</option>
                    </optgroup>
                    <optgroup label="科技效果">
                        <option value="matrix">🔢 數字雨</option>
                        <option value="particles">⚛️ 粒子流</option>
                        <option value="glitch">📺 故障效果</option>
                        <option value="neon">💎 霓虹</option>
                    </optgroup>
                    <optgroup label="魔法效果">
                        <option value="magic">🪄 魔法粒子</option>
                        <option value="fairy">🧚 仙女塵</option>
                        <option value="portal">🌀 傳送門</option>
                        <option value="runes">🔮 符文</option>
                    </optgroup>
                </select>
            </div>
            
            <div class="control-group">
                <label for="intensity">強度: <span id="intensityValue">50</span></label>
                <input type="range" id="intensity" min="10" max="200" value="50">
            </div>
            
            <div class="control-group">
                <label for="speed">速度: <span id="speedValue">2</span></label>
                <input type="range" id="speed" min="0.5" max="5" step="0.1" value="2">
            </div>
            
            <div class="control-group">
                <label for="size">大小: <span id="sizeValue">3</span></label>
                <input type="range" id="size" min="1" max="8" step="0.5" value="3">
            </div>

            <div class="control-group">
                <label for="colorMode">顏色模式</label>
                <select id="colorMode">
                    <option value="default">預設</option>
                    <option value="rainbow">彩虹</option>
                    <option value="monochrome">單色</option>
                    <option value="warm">暖色調</option>
                    <option value="cool">冷色調</option>
                </select>
            </div>

            <div class="control-group">
                <label for="blendMode">混合模式</label>
                <select id="blendMode">
                    <option value="normal">正常</option>
                    <option value="multiply">相乘</option>
                    <option value="screen">濾色</option>
                    <option value="overlay">覆蓋</option>
                    <option value="soft-light">柔光</option>
                    <option value="hard-light">強光</option>
                    <option value="difference">差異</option>
                    <option value="exclusion">排除</option>
                </select>
            </div>
            
            <div class="control-group">
                <label>快速設定</label>
                <button class="upload-btn" id="lowLoadBtn">⚙️ 低負載模式</button>
            </div>
        </div>

        <div class="media-container" id="mediaContainer">
            <img id="mediaElement" style="display: none;">
            <video id="videoElement" style="display: none;" controls muted loop></video>
            <canvas id="effectCanvas"></canvas>
        </div>

        <div class="download-section" id="downloadSection">
            <div class="download-options">
                <h3 style="text-align: center; margin-bottom: 20px;">💾 下載選項</h3>
                
                <div class="option-group">
                    <label for="duration">動畫時長: <span id="durationValue">5</span> 秒</label>
                    <input type="range" id="duration" min="3" max="15" value="5" style="width: 100%;">
                </div>
                
                <div class="option-group">
                    <label for="fps">幀率 (FPS)</label>
                    <select id="fps" style="width: 100%;">
                        <option value="15">15 FPS (檔案較小)</option>
                        <option value="24" selected>24 FPS (標準)</option>
                        <option value="30">30 FPS (流暢)</option>
                        <option value="60">60 FPS (超流暢)</option>
                    </select>
                </div>
                
                <div class="option-group">
                    <label for="quality">品質設定</label>
                    <select id="quality" style="width: 100%;">
                        <option value="0.3">低品質 (檔案最小)</option>
                        <option value="0.6">中品質</option>
                        <option value="0.8" selected>高品質</option>
                        <option value="1.0">最高品質</option>
                    </select>
                </div>
                
                <div class="progress-bar" id="progressBar">
                    <div class="progress-fill" id="progressFill"></div>
                </div>
                <div id="progressText" style="text-align: center; margin: 10px 0;"></div>
                
                <div style="text-align: center;">
                    <button class="download-btn" id="downloadGifBtn">🎞️ 下載 GIF 動畫</button>
                    <button class="download-btn" id="downloadMp4Btn">🎬 下載 WebM 影片</button>
                    <button class="download-btn" id="downloadImageBtn">🖼️ 下載靜態圖片</button>
                    
                </div>
            </div>
        </div>

       

    <script src="gif.js"></script>
    <!-- ffmpeg.wasm (local core files). Place files in libs/ffmpeg/ -->
    <script src="libs/ffmpeg/ffmpeg.min.js"></script>
    <script>
        // 強制所有 2D context 使用 willReadFrequently，包含 gif.js 內部建立的 canvas
        (function() {
            const originalGetContext = HTMLCanvasElement.prototype.getContext;
            HTMLCanvasElement.prototype.getContext = function(type, options) {
                if (type === '2d') {
                    const nextOptions = options && typeof options === 'object' ? {...options} : {};
                    if (!nextOptions.willReadFrequently) nextOptions.willReadFrequently = true;
                    return originalGetContext.call(this, type, nextOptions);
                }
                return originalGetContext.call(this, type, options);
            };
        })();
    </script>
    <script>
        class EnhancedEffectEngine {
            constructor() {
                this.canvas = document.getElementById('effectCanvas');
                this.ctx = this.canvas.getContext('2d', { willReadFrequently: true });
                this.particles = [];
                this.animationId = null;
                this.effectType = 'snow';
                this.intensity = 50;
                this.speed = 2;
                this.size = 3;
                this.colorMode = 'default';
                this.blendMode = 'normal';
                this.isImage = true;
                this.mediaElement = null;
                this.time = 0;
                
                // 特效相關屬性
                this.lightningFlashes = [];
                this.magicTrails = [];
                this.runeRotations = [];
                // 修正：用於煙火生成計時器，用於控制即時爆炸的頻率
                this.fireworkSpawnTimer = 0; 
                
                // ffmpeg core base URL（會在載入時動態決定）
                this.ffmpegCoreBase = 'https://unpkg.com/@ffmpeg/core@0.12.10/dist/ffmpeg-core.js';

                this.setupEventListeners();
            }
            
            async ensureFFmpeg() {
                if (this.ffmpeg && this.ffmpeg.isLoaded) return;
                if (!window.FFmpeg) throw new Error('FFmpeg library not loaded');
                const { createFFmpeg } = window.FFmpeg;
                this.ffmpeg = createFFmpeg({
                    log: false,
                    corePath: 'libs/ffmpeg/ffmpeg-core.js'
                });
                await this.ffmpeg.load();
            }
            
            async convertWebmToMp4(webmBlob) {
                await this.ensureFFmpeg();
                const data = new Uint8Array(await webmBlob.arrayBuffer());
                // 寫入輸入檔
                try { this.ffmpeg.FS('unlink', 'input.webm'); } catch(_) {}
                try { this.ffmpeg.FS('unlink', 'output.mp4'); } catch(_) {}
                this.ffmpeg.FS('writeFile', 'input.webm', data);
                // 轉檔：H.264 + yuv420p + faststart
                await this.ffmpeg.run(
                    '-i', 'input.webm',
                    '-c:v', 'libx264',
                    '-pix_fmt', 'yuv420p',
                    '-movflags', 'faststart',
                    '-an',
                    'output.mp4'
                );
                const out = this.ffmpeg.FS('readFile', 'output.mp4');
                return new Blob([out.buffer], { type: 'video/mp4' });
            }
            
            setupEventListeners() {
                const fileInput = document.getElementById('fileInput');
                const uploadArea = document.getElementById('uploadArea');
                const effectType = document.getElementById('effectType');
                const intensity = document.getElementById('intensity');
                const speed = document.getElementById('speed');
                const size = document.getElementById('size');
                const colorMode = document.getElementById('colorMode');
                const blendMode = document.getElementById('blendMode');
                const downloadGifBtn = document.getElementById('downloadGifBtn');
                const downloadMp4Btn = document.getElementById('downloadMp4Btn');
                const downloadImageBtn = document.getElementById('downloadImageBtn');
                const convertMp4Btn = document.getElementById('convertMp4Btn');
                const duration = document.getElementById('duration');
                const lowLoadBtn = document.getElementById('lowLoadBtn');
                
                // File upload
                fileInput.addEventListener('change', (e) => this.handleFile(e.target.files[0]));
                
                // Drag and drop
                uploadArea.addEventListener('dragover', (e) => {
                    e.preventDefault();
                    uploadArea.classList.add('dragover');
                });
                
                uploadArea.addEventListener('dragleave', () => {
                    uploadArea.classList.remove('dragover');
                });
                
                uploadArea.addEventListener('drop', (e) => {
                    e.preventDefault();
                    uploadArea.classList.remove('dragover');
                    this.handleFile(e.dataTransfer.files[0]);
                });
                
                // Controls
                effectType.addEventListener('change', (e) => {
                    this.effectType = e.target.value;
                    this.initParticles();
                });
                
                intensity.addEventListener('input', (e) => {
                    this.intensity = parseInt(e.target.value);
                    document.getElementById('intensityValue').textContent = e.target.value;
                    this.initParticles();
                });
                
                speed.addEventListener('input', (e) => {
                    this.speed = parseFloat(e.target.value);
                    document.getElementById('speedValue').textContent = e.target.value;
                });
                
                size.addEventListener('input', (e) => {
                    this.size = parseFloat(e.target.value);
                    document.getElementById('sizeValue').textContent = e.target.value;
                });
                
                colorMode.addEventListener('change', (e) => {
                    this.colorMode = e.target.value;
                });
                
                blendMode.addEventListener('change', (e) => {
                    this.blendMode = e.target.value;
                });
                
                duration.addEventListener('input', (e) => {
                    document.getElementById('durationValue').textContent = e.target.value;
                });
                
                // Download buttons
                downloadGifBtn.addEventListener('click', () => this.downloadGif());
                downloadMp4Btn.addEventListener('click', () => this.downloadMp4());
                downloadImageBtn.addEventListener('click', () => this.downloadImage());
                
                if (convertMp4Btn) {
                    convertMp4Btn.addEventListener('click', async () => {
                        try {
                            const picker = document.createElement('input');
                            picker.type = 'file';
                            picker.accept = 'video/webm';
                            picker.onchange = async () => {
                                const file = picker.files && picker.files[0];
                                if (!file) return;
                                this.setButtonsState(true);
                                this.showProgress('正在轉檔為 MP4 (瀏覽器端轉檔)...');
                                try {
                                    const mp4Blob = await this.convertWebmToMp4(file);
                                    const url = URL.createObjectURL(mp4Blob);
                                    const a = document.createElement('a');
                                    a.href = url;
                                    a.download = `convert_${Date.now()}.mp4`;
                                    a.click();
                                    URL.revokeObjectURL(url);
                                } catch (e) {
                                    console.error('轉檔 MP4 失敗：', e);
                                    alert('轉檔 MP4 失敗，請確認檔案或降低大小後重試');
                                } finally {
                                    this.hideProgress();
                                    this.setButtonsState(false);
                                }
                            };
                            picker.click();
                        } catch (e) {
                            console.error(e);
                            alert('轉檔器初始化失敗，請稍後重試');
                        }
                    });
                }

                // 快速低負載設定
                if (lowLoadBtn) {
                    lowLoadBtn.addEventListener('click', () => {
                        // 基本畫面參數
                        intensity.value = 30; this.intensity = 30; document.getElementById('intensityValue').textContent = '30';
                        size.value = 3; this.size = 3; document.getElementById('sizeValue').textContent = '3';
                        speed.value = 2; this.speed = 2; document.getElementById('speedValue').textContent = '2';
                        colorMode.value = 'default'; this.colorMode = 'default';
                        blendMode.value = 'normal'; this.blendMode = 'normal';
                        
                        // 下載參數
                        const fpsSel = document.getElementById('fps'); if (fpsSel) fpsSel.value = '15';
                        duration.value = 3; document.getElementById('durationValue').textContent = '3';
                        const qualitySel = document.getElementById('quality'); if (qualitySel) qualitySel.value = '0.6';
                        
                        // 重新產生粒子
                        this.initParticles();
                    });
                }
            }
            
            handleFile(file) {
                if (!file) return;
                
                const mediaContainer = document.getElementById('mediaContainer');
                const imgElement = document.getElementById('mediaElement');
                const videoElement = document.getElementById('videoElement');
                const downloadSection = document.getElementById('downloadSection');
                
                downloadSection.style.display = 'block';
                
                const reader = new FileReader();
                reader.onload = (e) => {
                    if (file.type.startsWith('image/')) {
                        this.isImage = true;
                        this.mediaElement = imgElement;
                        imgElement.src = e.target.result;
                        imgElement.style.display = 'block';
                        videoElement.style.display = 'none';
                        videoElement.pause();
                        
                        imgElement.onload = () => {
                            this.setupCanvas();
                            this.initParticles();
                            this.animate();
                        };
                    } else if (file.type.startsWith('video/')) {
                        this.isImage = false;
                        this.mediaElement = videoElement;
                        videoElement.src = e.target.result;
                        videoElement.style.display = 'block';
                        imgElement.style.display = 'none';
                        
                        videoElement.onloadedmetadata = () => {
                            this.setupCanvas();
                            this.initParticles();
                            this.animate();
                            videoElement.play();
                        };
                    }
                };
                reader.readAsDataURL(file);
                mediaContainer.style.display = 'block';
            }
            
            setupCanvas() {
                this.mediaElement = this.isImage ? 
                    document.getElementById('mediaElement') : 
                    document.getElementById('videoElement');
                
                const container = document.getElementById('mediaContainer');
                const targetWidth = (container && container.clientWidth) || this.mediaElement.offsetWidth || 300;
                const targetHeight = (container && container.clientHeight) || this.mediaElement.offsetHeight || 300;
                
                this.canvas.width = targetWidth;
                this.canvas.height = targetHeight;
            }
            
            getParticleColor(particle, baseColor = null) {
                const { colorMode } = this;
                let color = baseColor || 'white';
                
                switch (colorMode) {
                    case 'rainbow':
                        const hue = (particle.hue || 0) + this.time * 0.5;
                        color = `hsl(${hue % 360}, 70%, 60%)`;
                        break;
                    case 'monochrome':
                        const gray = Math.random() * 100 + 50;
                        color = `hsl(0, 0%, ${gray}%)`;
                        break;
                    case 'warm':
                        const warmHue = Math.random() * 60 + 300; // 紅-橙-黃
                        color = `hsl(${warmHue}, 70%, 60%)`;
                        break;
                    case 'cool':
                        const coolHue = Math.random() * 120 + 180; // 藍-綠-青
                        color = `hsl(${coolHue}, 70%, 60%)`;
                        break;
                }
                
                return color;
            }
             // --- 煙火特效的獨立輔助函式 ---

            // 創建一個火箭粒子 (Rocket)
            createRocket(explosionStyle = 'default') {
                return {
                    kind: 'rocket',
                    x: this.canvas.width * (0.1 + Math.random() * 0.8), // 隨機水平位置
                    y: this.canvas.height + 50, // 屏幕下方開始
                    vx: (Math.random() - 0.5) * 0.8,
                    vy: - (Math.random() * (2 + this.speed) * 0.8 + 4), // 初始上升速度
                    size: Math.random() * 1.5 + 1.5,
                    opacity: 1,
                    color: `hsl(${Math.floor(Math.random() * 360)}, 80%, 60%)`, // 隨機顏色
                    targetY: this.canvas.height * (0.1 + Math.random() * 0.4), // 隨機爆炸高度
                    trail: [],
                    explosionStyle: explosionStyle
                };
            }

            // 創建一個爆炸火花粒子 (Spark)
            createSpark(x, y, color, angle, velocity, life, size) {
                return {
                    kind: 'spark',
                    x: x,
                    y: y,
                    vx: Math.cos(angle) * velocity,
                    vy: Math.sin(angle) * velocity,
                    size: size,
                    opacity: 1,
                    color: color,
                    life: life,
                    maxLife: life
                };
            }

            // 根據火箭資訊生成爆炸火花
            createExplosion(rocket) {
                const sparks = [];
                // 火花數量根據強度和類型決定
                const numSparks = rocket.explosionStyle === 'big' ? Math.floor(this.intensity * 0.5) + 50 : Math.floor(this.intensity * 0.3) + 30;
                const baseVelocity = 3 + (this.speed * 0.5);
                const sparkColor = rocket.color; // 沿用火箭顏色

                if (rocket.explosionStyle === 'heart') {
                    // 愛心形狀爆炸
                    for (let i = 0; i < numSparks; i++) {
                        const t = i / numSparks * Math.PI * 2;
                        
                        // 愛心參數方程式
                        let x = 16 * Math.pow(Math.sin(t), 3);
                        let y = -(13 * Math.cos(t) - 5 * Math.cos(2 * t) - 2 * Math.cos(3 * t) - Math.cos(4 * t));
                        
                        // 轉換為角度和速度
                        const angle = Math.atan2(y, x);
                        const distance = Math.hypot(x, y);

                        const velocityScale = Math.random() * 0.5 + 0.5;
                        const velocity = baseVelocity * 0.15 + (distance * 0.05); // 讓外圈速度快一點

                        sparks.push(this.createSpark(
                            rocket.x, 
                            rocket.y, 
                            sparkColor, 
                            angle, 
                            velocity * velocityScale, 
                            Math.random() * 40 + 60,
                            Math.random() * 1.5 + 1
                        ));
                    }
                } else {
                    // 標準或大型圓形爆炸
                    for (let i = 0; i < numSparks; i++) {
                        const angle = Math.random() * Math.PI * 2;
                        const velocity = baseVelocity * (Math.random() * 0.5 + 0.5);
                        const life = Math.random() * 50 + 70;
                        const size = Math.random() * 1.5 + 1;

                        sparks.push(this.createSpark(
                            rocket.x, 
                            rocket.y, 
                            sparkColor, 
                            angle, 
                            velocity, 
                            life,
                            size
                        ));
                    }
                }

                // 將火花加入到粒子陣列中
                this.particles.push(...sparks);
            }
            
            // --- 粒子初始化 ---
            initParticles() {
                this.particles = [];
                this.lightningFlashes = [];
                this.magicTrails = [];
                this.runeRotations = [];
                 this.fireworkSpawnTimer = 0;
                
                // 設定煙火爆炸樣式
                let explosionStyle = 'default';
                if (this.effectType === 'fireworks_big') explosionStyle = 'big';
                if (this.effectType === 'fireworks_heart') explosionStyle = 'heart';
                
                // Fireworks 初始化
                if (this.effectType === 'fireworks') {
                    // 🎆 煙火：無火箭，只使用計時器在空中生成爆炸
                    this.fireworkSpawnTimer = 1; 
                } else if (this.effectType.startsWith('fireworks')) {
                    // 🎇/💖 煙火：保留火箭上升的邏輯
                    const rocketCount = Math.max(3, Math.floor(this.intensity / 5)); 
                    for (let i = 0; i < rocketCount; i++) {
                        this.particles.push(this.createRocket(explosionStyle));
                    }
                } else {
                    // 初始化其他特效的粒子
                    for (let i = 0; i < this.intensity; i++) {
                        this.particles.push(this.createParticle());
                    }
                }
                
                // 初始化符文旋轉角度
                if (this.effectType === 'runes') {
                    for (let i = 0; i < this.intensity; i++) {
                        this.runeRotations.push(Math.random() * Math.PI * 2);
                    }
                }
            }
            
            createParticle() {
                const particle = {
                    x: Math.random() * this.canvas.width,
                    y: Math.random() * this.canvas.height - this.canvas.height,
                    vx: 0,
                    vy: 0,
                    size: Math.random() * this.size + 1,
                    opacity: Math.random() * 0.8 + 0.2,
                    angle: 0,
                    hue: Math.random() * 360,
                    life: 1,
                    maxLife: 1,
                    trail: []
                };
                
                switch (this.effectType) {
                    case 'snow':
                        particle.vx = (Math.random() - 0.5) * 0.5;
                        particle.vy = Math.random() * this.speed + 0.5;
                        break;
                    case 'rain':
                        particle.vx = Math.random() * 2 - 1;
                        particle.vy = Math.random() * this.speed + 3;
                        particle.size = Math.random() * 2 + 1;
                        break;
                    case 'storm':
                        particle.vx = Math.random() * 4 - 2;
                        particle.vy = Math.random() * this.speed + 5;
                        particle.size = Math.random() * 3 + 1;
                        break;
                    case 'lightning':
                        particle.vx = 0;
                        particle.vy = 0;
                        particle.life = Math.random() * 0.3 + 0.1;
                        particle.maxLife = particle.life;
                        break;
                    case 'leaves':
                        particle.vx = Math.random() * 2 - 1;
                        particle.vy = Math.random() * this.speed + 1;
                        particle.angle = Math.random() * Math.PI * 2;
                        break;
                    case 'sakura':
                        particle.vx = Math.random() * 1 - 0.5;
                        particle.vy = Math.random() * this.speed + 0.5;
                        particle.angle = Math.random() * Math.PI * 2;
                        break;
                    case 'fireflies':
                        particle.vx = (Math.random() - 0.5) * 2;
                        particle.vy = (Math.random() - 0.5) * 2;
                        particle.glowIntensity = Math.random();
                        break;
                    case 'butterflies':
                        particle.vx = Math.random() * 2 - 1;
                        particle.vy = Math.random() * this.speed + 0.5;
                        particle.wingPhase = Math.random() * Math.PI * 2;
                        break;
                    case 'stars':
                        particle.vx = (Math.random() - 0.5) * 0.2;
                        particle.vy = Math.random() * this.speed * 0.5 + 0.2;
                        particle.twinkle = Math.random() * Math.PI * 2;
                        break;
                    case 'bubbles':
                        particle.vx = (Math.random() - 0.5) * 1;
                        particle.vy = -Math.random() * this.speed - 0.5;
                        particle.size = Math.random() * this.size + 2;
                        break;
                    case 'hearts':
                        particle.vx = (Math.random() - 0.5) * 1;
                        particle.vy = Math.random() * this.speed + 0.5;
                        particle.pulse = Math.random() * Math.PI * 2;
                        particle.size = Math.random() * 4 + 4; // 愛心預設值增大
                        break;
                    case 'sparkles':
                        particle.vx = (Math.random() - 0.5) * 2;
                        particle.vy = (Math.random() - 0.5) * 2;
                        particle.sparklePhase = Math.random() * Math.PI * 2;
                        break;
                    case 'matrix':
                        particle.vx = 0;
                        particle.vy = Math.random() * this.speed + 2;
                        particle.char = String.fromCharCode(0x30A0 + Math.random() * 96);
                        break;
                    case 'particles':
                        const angle = Math.random() * Math.PI * 2;
                        particle.vx = Math.cos(angle) * this.speed;
                        particle.vy = Math.sin(angle) * this.speed;
                        break;
                    case 'glitch':
                        particle.vx = (Math.random() - 0.5) * 10;
                        particle.vy = (Math.random() - 0.5) * 10;
                        particle.life = Math.random() * 0.2 + 0.1;
                        particle.maxLife = particle.life;
                        break;
                    case 'neon':
                        particle.vx = (Math.random() - 0.5) * 1;
                        particle.vy = Math.random() * this.speed + 1;
                        particle.glowSize = Math.random() * 10 + 5;
                        break;
                    case 'magic':
                        particle.vx = (Math.random() - 0.5) * 3;
                        particle.vy = (Math.random() - 0.5) * 3;
                        particle.trail = [];
                        break;
                    case 'fairy':
                        particle.vx = (Math.random() - 0.5) * 2;
                        particle.vy = -Math.random() * this.speed - 0.5;
                        particle.shimmer = Math.random() * Math.PI * 2;
                        break;
                    case 'portal':
                        const radius = Math.random() * 100 + 50;
                        const portalAngle = Math.random() * Math.PI * 2;
                        particle.x = this.canvas.width / 2 + Math.cos(portalAngle) * radius;
                        particle.y = this.canvas.height / 2 + Math.sin(portalAngle) * radius;
                        particle.vx = -Math.cos(portalAngle) * this.speed;
                        particle.vy = -Math.sin(portalAngle) * this.speed;
                        break;
                    case 'runes':
                        particle.vx = (Math.random() - 0.5) * 0.5;
                        particle.vy = Math.random() * this.speed + 0.5;
                        particle.runeType = Math.floor(Math.random() * 6);
                        break;
                }
                
                return particle;
            }
            
            updateParticle(particle, index) {
                particle.x += particle.vx;
                particle.y += particle.vy;
                
                // 特效特殊更新邏輯
                switch (this.effectType) {
                    case 'fireworks_big':
                    case 'fireworks_heart':
                        if (particle.kind === 'rocket') {
                            // 火箭上升和重力 (減速)
                            particle.vy += 0.08; 
                            
                            // 拖尾管理
                            particle.trail.push({ x: particle.x, y: particle.y, life: 1, color: particle.color });
                            particle.trail = particle.trail.filter(t => (t.life -= 0.05) > 0); 

                            // 爆炸判斷: 到達目標高度或開始明顯下墜 (vy > 1)
                            if (particle.y <= particle.targetY || particle.vy > 1) { 
                                // 1. 創建爆炸火花
                                this.createExplosion(particle);
                                
                                // 2. 重設火箭狀態，準備下一次發射
                                const newRocket = this.createRocket(particle.explosionStyle);
                                Object.assign(particle, newRocket); 
                                return;
                            }
                        } else if (particle.kind === 'spark') {
                            // 火花受重力和摩擦影響
                            particle.vy += 0.04; // 重力
                            particle.vx *= 0.98; // 摩擦
                            particle.vy *= 0.98; // 摩擦
                            
                            // 逐漸淡出
                            particle.life -= 1;
                            particle.opacity = particle.life / particle.maxLife; 
                            
                            // 移除死亡的火花
                            if (particle.life <= 0) {
                                this.particles.splice(index, 1);
                                return; // 已移除，結束處理
                            }
                        }
                        break; // <-- 結束 fireworks_big/heart 的邏輯

                    case 'fireworks': // <-- 🎆 煙火：只有火花
                        if (particle.kind === 'spark') {
                            // 火花受重力和摩擦影響 (與其他煙火火花一樣)
                            particle.vy += 0.04; // 重力
                            particle.vx *= 0.98; // 摩擦
                            particle.vy *= 0.98; // 摩擦
                            
                            // 逐漸淡出
                            particle.life -= 1;
                            particle.opacity = particle.life / particle.maxLife; 
                            
                            // 移除死亡的火花
                            if (particle.life <= 0) {
                                this.particles.splice(index, 1);
                                return; 
                            }
                        } else {
                            // 確保非火花粒子被移除 (雖然不應該出現)
                            this.particles.splice(index, 1);
                            return;
                        }
                        break;
                    case 'leaves':
                    case 'sakura':
                        particle.angle += 0.02;
                        particle.x += Math.sin(particle.angle) * 0.5;
                        break;
                    case 'fireflies':
                        particle.vx += (Math.random() - 0.5) * 0.1;
                        particle.vy += (Math.random() - 0.5) * 0.1;
                        particle.glowIntensity = Math.sin(this.time * 0.1 + index) * 0.5 + 0.5;
                        break;
                    case 'butterflies':
                        particle.wingPhase += 0.3;
                        particle.vy += Math.sin(particle.wingPhase) * 0.1;
                        break;
                    case 'stars':
                        particle.twinkle += 0.1;
                        break;
                    case 'hearts':
                        particle.pulse += 0.1;
                        break;
                    case 'sparkles':
                        particle.sparklePhase += 0.2;
                        break;
                    case 'lightning':
                        particle.life -= 0.02;
                        if (particle.life <= 0) {
                            particle.life = Math.random() * 0.3 + 0.1;
                            particle.maxLife = particle.life;
                            particle.x = Math.random() * this.canvas.width;
                            particle.y = Math.random() * this.canvas.height;
                        }
                        break;
                    case 'particles':
                        particle.life -= 0.01;
                        if (particle.life <= 0) {
                            particle.life = 1;
                            particle.x = this.canvas.width / 2;
                            particle.y = this.canvas.height / 2;
                            const angle = Math.random() * Math.PI * 2;
                            particle.vx = Math.cos(angle) * this.speed;
                            particle.vy = Math.sin(angle) * this.speed;
                        }
                        break;
                    case 'glitch':
                        particle.life -= 0.05;
                        if (particle.life <= 0) {
                            particle.life = Math.random() * 0.2 + 0.1;
                            particle.maxLife = particle.life;
                            particle.x = Math.random() * this.canvas.width;
                            particle.y = Math.random() * this.canvas.height;
                        }
                        break;
                    case 'magic':
                        particle.trail.push({x: particle.x, y: particle.y, life: 1});
                        particle.trail = particle.trail.filter(t => t.life > 0);
                        particle.trail.forEach(t => t.life -= 0.05);
                        
                        particle.vx += (Math.random() - 0.5) * 0.2;
                        particle.vy += (Math.random() - 0.5) * 0.2;
                        break;
                    case 'fairy':
                        particle.shimmer += 0.15;
                        break;
                    case 'portal':
                        const centerX = this.canvas.width / 2;
                        const centerY = this.canvas.height / 2;
                        const dist = Math.hypot(particle.x - centerX, particle.y - centerY);
                        if (dist < 50) {
                            const radius = Math.random() * 100 + 50;
                            const portalAngle = Math.random() * Math.PI * 2;
                            particle.x = centerX + Math.cos(portalAngle) * radius;
                            particle.y = centerY + Math.sin(portalAngle) * radius;
                            particle.vx = -Math.cos(portalAngle) * this.speed;
                            particle.vy = -Math.sin(portalAngle) * this.speed;
                        }
                        break;
                    case 'runes':
                        if (this.runeRotations[index] !== undefined) {
                            this.runeRotations[index] += 0.02;
                        }
                        break;
                }
                
                // 重置超出邊界的粒子
                if (this.needsReset(particle)) {
                    this.resetParticle(particle);
                }
            }
            
            needsReset(particle) {
                switch (this.effectType) {
                    case 'bubbles':
                        return particle.y < -particle.size;
                    case 'lightning':
                    case 'glitch':
                    case 'particles':
                        return false; // 這些效果有自己的生命週期
                    case 'portal':
                        return false; // 傳送門效果有特殊邏輯
                    default:
                        return particle.y > this.canvas.height + particle.size || 
                               particle.x < -particle.size || 
                               particle.x > this.canvas.width + particle.size;
                }
            }
            
            resetParticle(particle) {
                switch (this.effectType) {
                    case 'bubbles':
                        particle.y = this.canvas.height + particle.size;
                        particle.x = Math.random() * this.canvas.width;
                        particle.vy = -Math.random() * this.speed - 0.5;
                        break;
                    default:
                        particle.y = -particle.size;
                        particle.x = Math.random() * this.canvas.width;
                        if (this.effectType === 'storm') {
                            particle.vx = Math.random() * 4 - 2;
                        }
                        break;
                }
            }
            
            drawParticle(particle, index) {
                this.ctx.save();
                this.ctx.globalCompositeOperation = this.blendMode;
                this.ctx.globalAlpha = particle.opacity;
                
                switch (this.effectType) {
                    case 'snow':
                        this.ctx.fillStyle = this.getParticleColor(particle, 'white');
                        this.ctx.beginPath();
                        this.ctx.arc(particle.x, particle.y, particle.size, 0, Math.PI * 2);
                        this.ctx.fill();
                        break;
                        
                    case 'rain':
                    case 'storm':
                        this.ctx.strokeStyle = this.getParticleColor(particle, 'rgba(174, 194, 224, 0.8)');
                        this.ctx.lineWidth = particle.size;
                        this.ctx.beginPath();
                        this.ctx.moveTo(particle.x, particle.y);
                        this.ctx.lineTo(particle.x + particle.vx * 5, particle.y + particle.vy * 5);
                        this.ctx.stroke();
                        break;
                        
                    case 'lightning':
                        if (Math.random() < 0.1) { // 閃電出現機率
                            this.drawLightning();
                        }
                        break;
                        
                    case 'leaves':
                        this.ctx.translate(particle.x, particle.y);
                        this.ctx.rotate(particle.angle);
                        this.ctx.fillStyle = this.getParticleColor(particle, `hsl(${30 + Math.random() * 60}, 70%, 50%)`);
                        this.ctx.beginPath();
                        this.ctx.ellipse(0, 0, particle.size, particle.size * 0.6, 0, 0, Math.PI * 2);
                        this.ctx.fill();
                        break;
                        
                    case 'sakura':
                        this.drawSakuraPetal(particle);
                        break;
                        
                    case 'fireflies':
                        const glowSize = particle.size * (2 + particle.glowIntensity * 2);
                        const gradient = this.ctx.createRadialGradient(particle.x, particle.y, 0, particle.x, particle.y, glowSize);
                        gradient.addColorStop(0, this.getParticleColor(particle, 'rgba(255, 255, 100, 0.8)'));
                        gradient.addColorStop(1, 'rgba(255, 255, 100, 0)');
                        this.ctx.fillStyle = gradient;
                        this.ctx.beginPath();
                        this.ctx.arc(particle.x, particle.y, glowSize, 0, Math.PI * 2);
                        this.ctx.fill();
                        break;
                        
                    case 'butterflies':
                        this.drawButterfly(particle);
                        break;
                        
                    case 'stars':
                        const twinkleOpacity = Math.sin(particle.twinkle) * 0.5 + 0.5;
                        this.ctx.globalAlpha *= twinkleOpacity;
                        this.ctx.fillStyle = this.getParticleColor(particle, 'gold');
                        this.drawStar(particle.x, particle.y, 5, particle.size, particle.size * 0.5);
                        break;
                        
                    case 'bubbles':
                        const bubbleGradient = this.ctx.createRadialGradient(
                            particle.x - particle.size * 0.3, particle.y - particle.size * 0.3, 0,
                            particle.x, particle.y, particle.size
                        );
                        bubbleGradient.addColorStop(0, 'rgba(255, 255, 255, 0.8)');
                        bubbleGradient.addColorStop(0.7, this.getParticleColor(particle, 'rgba(173, 216, 230, 0.4)'));
                        bubbleGradient.addColorStop(1, 'rgba(173, 216, 230, 0.1)');
                        
                        this.ctx.fillStyle = bubbleGradient;
                        this.ctx.beginPath();
                        this.ctx.arc(particle.x, particle.y, particle.size, 0, Math.PI * 2);
                        this.ctx.fill();
                        this.ctx.strokeStyle = this.getParticleColor(particle, 'rgba(173, 216, 230, 0.6)');
                        this.ctx.lineWidth = 1;
                        this.ctx.stroke();
                        break;
                        
                    case 'hearts':
                        const pulseSize = particle.size * (1 + Math.sin(particle.pulse) * 0.3);
                        this.drawHeart(particle.x, particle.y, pulseSize);
                        break;
                        
                    case 'sparkles':
                        const sparkleOpacity = Math.sin(particle.sparklePhase) * 0.5 + 0.5;
                        this.ctx.globalAlpha *= sparkleOpacity;
                        this.drawSparkle(particle);
                        break;
                        
                    case 'matrix':
                        this.ctx.fillStyle = this.getParticleColor(particle, '#00ff00');
                        this.ctx.font = `${particle.size * 5}px monospace`;
                        this.ctx.fillText(particle.char, particle.x, particle.y);
                        break;
                        
                    case 'particles':
                        const particleAlpha = particle.life;
                        this.ctx.globalAlpha *= particleAlpha;
                        this.ctx.fillStyle = this.getParticleColor(particle, '#00ffff');
                        this.ctx.beginPath();
                        this.ctx.arc(particle.x, particle.y, particle.size, 0, Math.PI * 2);
                        this.ctx.fill();
                        break;
                        
                    case 'glitch':
                        const glitchAlpha = particle.life / particle.maxLife;
                        this.ctx.globalAlpha *= glitchAlpha;
                        this.ctx.fillStyle = this.getParticleColor(particle, '#ff00ff');
                        this.ctx.fillRect(particle.x, particle.y, particle.size * 3, particle.size);
                        break;
                        
                    case 'neon':
                        const neonGradient = this.ctx.createRadialGradient(
                            particle.x, particle.y, 0,
                            particle.x, particle.y, particle.glowSize
                        );
                        neonGradient.addColorStop(0, this.getParticleColor(particle, '#ff00ff'));
                        neonGradient.addColorStop(1, 'rgba(255, 0, 255, 0)');
                        this.ctx.fillStyle = neonGradient;
                        this.ctx.beginPath();
                        this.ctx.arc(particle.x, particle.y, particle.glowSize, 0, Math.PI * 2);
                        this.ctx.fill();
                        break;
                        
                    case 'magic':
                        // 繪製軌跡（提高亮度與尺寸）
                        particle.trail.forEach((t, i) => {
                            this.ctx.globalAlpha = Math.min(1, t.life * 0.8);
                            this.ctx.fillStyle = this.getParticleColor(particle, '#b266ff');
                            this.ctx.beginPath();
                            this.ctx.arc(t.x, t.y, particle.size * (t.life * 1.5 + 0.5), 0, Math.PI * 2);
                            this.ctx.fill();
                        });
                        
                        // 繪製主粒子
                        this.ctx.globalAlpha = Math.min(1, particle.opacity * 1.2);
                        this.ctx.fillStyle = this.getParticleColor(particle, '#ff89c6');
                        this.drawStar(particle.x, particle.y, 6, particle.size * 2.5, particle.size * 1.2);
                        break;
                        
                    case 'fairy':
                        const shimmerOpacity = Math.sin(particle.shimmer) * 0.3 + 0.9;
                        this.ctx.globalAlpha *= shimmerOpacity;
                        const fairyGradient = this.ctx.createRadialGradient(
                            particle.x, particle.y, 0,
                            particle.x, particle.y, particle.size * 4
                        );
                        fairyGradient.addColorStop(0, this.getParticleColor(particle, 'rgba(255, 200, 220, 0.95)'));
                        fairyGradient.addColorStop(1, 'rgba(255, 200, 220, 0)');
                        this.ctx.fillStyle = fairyGradient;
                        this.ctx.beginPath();
                        this.ctx.arc(particle.x, particle.y, particle.size * 4, 0, Math.PI * 2);
                        this.ctx.fill();
                        break;
                        
                    case 'portal':
                        const centerX = this.canvas.width / 2;
                        const centerY = this.canvas.height / 2;
                        const distance = Math.sqrt((particle.x - centerX) ** 2 + (particle.y - centerY) ** 2);
                        const radiusFade = Math.max(this.canvas.width, this.canvas.height) * 0.4; // 自適應容器
                        const portalOpacity = 1 - (distance / radiusFade);
                        this.ctx.globalAlpha *= Math.max(0.2, Math.min(1, portalOpacity));
                        this.ctx.fillStyle = this.getParticleColor(particle, '#4e7bff');
                        this.ctx.beginPath();
                        this.ctx.arc(particle.x, particle.y, particle.size * 1.2, 0, Math.PI * 2);
                        this.ctx.fill();
                        break;
                        
                    case 'runes':
                        this.drawRune(particle, index);
                        break;
                }
                
                this.ctx.restore();
            }
            
            drawLightning() {
                this.ctx.save();
                this.ctx.strokeStyle = this.getParticleColor({hue: 60}, 'rgba(255, 255, 255, 0.9)');
                this.ctx.lineWidth = Math.random() * 3 + 1;
                this.ctx.shadowColor = 'white';
                this.ctx.shadowBlur = 10;
                
                let x = Math.random() * this.canvas.width;
                let y = 0;
                
                this.ctx.beginPath();
                this.ctx.moveTo(x, y);
                
                while (y < this.canvas.height) {
                    x += (Math.random() - 0.5) * 50;
                    y += Math.random() * 30 + 20;
                    this.ctx.lineTo(x, y);
                }
                
                this.ctx.stroke();
                this.ctx.restore();
            }
            
            drawSakuraPetal(particle) {
                this.ctx.translate(particle.x, particle.y);
                this.ctx.rotate(particle.angle);
                
                this.ctx.fillStyle = this.getParticleColor(particle, '#ffb6c1');
                this.ctx.beginPath();
                
                // 繪製櫻花花瓣形狀
                for (let i = 0; i < 5; i++) {
                    const angle = (i / 5) * Math.PI * 2;
                    const petalX = Math.cos(angle) * particle.size;
                    const petalY = Math.sin(angle) * particle.size * 0.6;
                    
                    if (i === 0) {
                        this.ctx.moveTo(petalX, petalY);
                    } else {
                        this.ctx.quadraticCurveTo(0, 0, petalX, petalY);
                    }
                }
                
                this.ctx.closePath();
                this.ctx.fill();
            }
            
            drawButterfly(particle) {
                this.ctx.translate(particle.x, particle.y);
                
                const wingFlap = Math.sin(particle.wingPhase) * 0.3;
                
                // 左翅膀
                this.ctx.save();
                this.ctx.rotate(wingFlap);
                this.ctx.fillStyle = this.getParticleColor(particle, '#ff69b4');
                this.ctx.beginPath();
                this.ctx.ellipse(-particle.size, 0, particle.size, particle.size * 0.5, 0, 0, Math.PI * 2);
                this.ctx.fill();
                this.ctx.restore();
                
                // 右翅膀
                this.ctx.save();
                this.ctx.rotate(-wingFlap);
                this.ctx.fillStyle = this.getParticleColor(particle, '#ff69b4');
                this.ctx.beginPath();
                this.ctx.ellipse(particle.size, 0, particle.size, particle.size * 0.5, 0, 0, Math.PI * 2);
                this.ctx.fill();
                this.ctx.restore();
                
                // 身體
                this.ctx.fillStyle = '#8b4513';
                this.ctx.fillRect(-1, -particle.size, 2, particle.size * 2);
            }
            
            drawHeart(x, y, size) {
                this.ctx.fillStyle = this.getParticleColor({hue: 0}, '#ff1493');
                this.ctx.beginPath();
                this.ctx.moveTo(x, y + size / 4);
                this.ctx.quadraticCurveTo(x - size / 2, y - size / 4, x - size / 4, y);
                this.ctx.quadraticCurveTo(x, y + size / 4, x, y + size / 2);
                this.ctx.quadraticCurveTo(x, y + size / 4, x + size / 4, y);
                this.ctx.quadraticCurveTo(x + size / 2, y - size / 4, x, y + size / 4);
                this.ctx.closePath();
                this.ctx.fill();
            }
            
            drawSparkle(particle) {
                const sparkleColor = this.getParticleColor(particle, '#ffd700');
                this.ctx.fillStyle = sparkleColor;
                this.ctx.strokeStyle = sparkleColor;
                this.ctx.lineWidth = 2;
                
                // 繪製十字形閃爍
                this.ctx.beginPath();
                this.ctx.moveTo(particle.x - particle.size, particle.y);
                this.ctx.lineTo(particle.x + particle.size, particle.y);
                this.ctx.moveTo(particle.x, particle.y - particle.size);
                this.ctx.lineTo(particle.x, particle.y + particle.size);
                
                // 繪製對角線
                this.ctx.moveTo(particle.x - particle.size * 0.7, particle.y - particle.size * 0.7);
                this.ctx.lineTo(particle.x + particle.size * 0.7, particle.y + particle.size * 0.7);
                this.ctx.moveTo(particle.x + particle.size * 0.7, particle.y - particle.size * 0.7);
                this.ctx.lineTo(particle.x - particle.size * 0.7, particle.y + particle.size * 0.7);
                
                this.ctx.stroke();
            }
            
            drawRune(particle, index) {
                this.ctx.translate(particle.x, particle.y);
                this.ctx.rotate(this.runeRotations[index] || 0);
                
                this.ctx.strokeStyle = this.getParticleColor(particle, '#b08cff');
                this.ctx.lineWidth = 2.5;
                this.ctx.shadowColor = '#b08cff';
                this.ctx.shadowBlur = 8;
                
                const runeSymbols = [
                    // 不同的符文符號路徑
                    () => { // 三角形
                        this.ctx.beginPath();
                        this.ctx.moveTo(0, -particle.size);
                        this.ctx.lineTo(-particle.size * 0.8, particle.size * 0.5);
                        this.ctx.lineTo(particle.size * 0.8, particle.size * 0.5);
                        this.ctx.closePath();
                        this.ctx.stroke();
                    },
                    () => { // 圓形帶十字
                        this.ctx.beginPath();
                        this.ctx.arc(0, 0, particle.size, 0, Math.PI * 2);
                        this.ctx.stroke();
                        this.ctx.beginPath();
                        this.ctx.moveTo(-particle.size, 0);
                        this.ctx.lineTo(particle.size, 0);
                        this.ctx.moveTo(0, -particle.size);
                        this.ctx.lineTo(0, particle.size);
                        this.ctx.stroke();
                    },
                    () => { // 六邊形
                        this.ctx.beginPath();
                        for (let i = 0; i < 6; i++) {
                            const angle = (i / 6) * Math.PI * 2;
                            const x = Math.cos(angle) * particle.size;
                            const y = Math.sin(angle) * particle.size;
                            if (i === 0) this.ctx.moveTo(x, y);
                            else this.ctx.lineTo(x, y);
                        }
                        this.ctx.closePath();
                        this.ctx.stroke();
                    }
                ];
                
                const runeType = particle.runeType % runeSymbols.length;
                runeSymbols[runeType]();
            }
            
            drawStar(x, y, points, outer, inner) {
                this.ctx.save();
                this.ctx.translate(x, y);
                this.ctx.beginPath();
                
                for (let i = 0; i < points * 2; i++) {
                    const angle = (i * Math.PI) / points;
                    const radius = i % 2 === 0 ? outer : inner;
                    const dx = Math.cos(angle) * radius;
                    const dy = Math.sin(angle) * radius;
                    
                    if (i === 0) {
                        this.ctx.moveTo(dx, dy);
                    } else {
                        this.ctx.lineTo(dx, dy);
                    }
                }
                
                this.ctx.closePath();
                this.ctx.fill();
                this.ctx.restore();
            }
            
            animate() {
                this.time += 1;
                this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
                
                this.particles.forEach((particle, index) => {
                    this.updateParticle(particle, index);
                    this.drawParticle(particle, index);
                });
                
                this.animationId = requestAnimationFrame(() => this.animate());
            }
            
            // 下載 GIF（增強：影片逐幀前進、worker 失敗時單執行緒回退）
            async downloadGif() {
                this.setButtonsState(true);
                this.showProgress('正在生成 GIF 動畫...');
                
                const fps = parseInt(document.getElementById('fps').value);
                const duration = parseInt(document.getElementById('duration').value);
                const quality = parseFloat(document.getElementById('quality').value);
                const totalFrames = fps * duration;
                const maxFrames = Math.min(totalFrames, 180); // 上限避免超長編碼卡住
                
                const renderWithConfig = async (gifConfig) => {
                    return new Promise(async (resolve, reject) => {
                        try {
                            const gif = new GIF({
                                repeat: 0,
                                // transparent: 'rgba(0,0,0,0)', // 關閉透明以減少計算量
                                // 提高取樣步長可減少運算（數值越大畫質越低、速度越快）
                                quality: Math.max(10, gifConfig.quality || 10),
                                dither: false,
                                ...gifConfig
                            });
                            
                            // 暫停即時動畫，避免與擷取流程互相影響
                            if (this.animationId) {
                                cancelAnimationFrame(this.animationId);
                                this.animationId = null;
                            }
                            
                            // 單一暫存畫布以降低記憶體壓力
                            const tempCanvas = document.createElement('canvas');
                            const tempCtx = tempCanvas.getContext('2d', { willReadFrequently: true });
                            tempCanvas.width = this.canvas.width;
                            tempCanvas.height = this.canvas.height;
                            
                            const renderFrameAsync = async (i) => {
                                // 若為影片，將影片時間推進到對應幀
                                if (!this.isImage && this.mediaElement.readyState >= 2) {
                                    const targetTime = (i / fps) % (this.mediaElement.duration || 99999);
                                    if (Math.abs(this.mediaElement.currentTime - targetTime) > 0.01) {
                                        await new Promise((res) => {
                                            const onSeeked = () => {
                                                this.mediaElement.removeEventListener('seeked', onSeeked);
                                                res();
                                            };
                                            this.mediaElement.addEventListener('seeked', onSeeked, { once: true });
                                            this.mediaElement.currentTime = targetTime;
                                        });
                                    }
                                }
                                
                                // 繪製底圖
                                tempCtx.clearRect(0, 0, tempCanvas.width, tempCanvas.height);
                                tempCtx.drawImage(this.mediaElement, 0, 0, tempCanvas.width, tempCanvas.height);
                                
                                // 在臨時上下文上渲染特效
                                this.particles.forEach((particle, index) => {
                                    this.updateParticle(particle, index);
                                    this.ctx = tempCtx;
                                    this.drawParticle(particle, index);
                                });
                                this.ctx = this.canvas.getContext('2d', { willReadFrequently: true });
                                
                                gif.addFrame(tempCanvas, { delay: Math.round(1000 / fps), copy: true, dispose: 2 });
                                
                                const progress = ((i + 1) / totalFrames) * 50;
                                this.updateProgress(progress, `生成幀 ${i + 1}/${totalFrames}`);
                            };
                            
                            // 逐步非同步處理，避免長時間阻塞
                            for (let i = 0; i < maxFrames; i++) {
                                await renderFrameAsync(i);
                                await new Promise(r => setTimeout(r, 0));
                            }
                            
                            // 監控編碼是否卡住
                            let lastProgress = 0;
                            let lastTick = Date.now();
                            const watchdog = setInterval(() => {
                                if (Date.now() - lastTick > 15000) { // 15 秒無進度
                                    clearInterval(watchdog);
                                    try { if (typeof gif.abort === 'function') gif.abort(); } catch(_) {}
                                    reject(new Error('stalled'));
                                }
                            }, 3000);
                            
                            gif.on('progress', (p) => {
                                this.updateProgress(50 + p * 50, '正在編碼 GIF...');
                                if (p > lastProgress) {
                                    lastProgress = p;
                                    lastTick = Date.now();
                                }
                            });
                            
                            gif.on('finished', (blob) => {
                                try { clearInterval(watchdog); } catch(_) {}
                                const url = URL.createObjectURL(blob);
                                const a = document.createElement('a');
                                a.href = url;
                                a.download = `effect_${this.effectType}_${Date.now()}.gif`;
                                a.click();
                                URL.revokeObjectURL(url);
                                resolve();
                            });
                            
                            gif.on('abort', () => reject(new Error('GIF 編碼被中止')));
                            gif.on('error', (err) => reject(err || new Error('GIF 編碼發生錯誤')));
                            
                            gif.render();
                        } catch (e) {
                            reject(e);
                        }
                    });
                };
                
                try {
                    // 先嘗試使用 workers（較穩定與快速）
                    await renderWithConfig({
                        workers: 2,
                        quality: Math.round((1 - quality) * 20) + 8, // 提高數值以加速
                        width: this.canvas.width,
                        height: this.canvas.height,
                        workerScript: 'gif.worker.js'
                    });
                } catch (err) {
                    console.warn('Workers 生成失敗或卡住，改用單執行緒低負載模式...', err);
                    try {
                        await renderWithConfig({
                            workers: 0,
                            quality: Math.round((1 - quality) * 20) + 12, // 再提高以降低負擔
                            width: this.canvas.width,
                            height: this.canvas.height
                        });
                    } catch (err2) {
                        console.error('GIF generation failed:', err2);
                        alert('GIF 生成失敗。請嘗試「低負載模式」，或進一步降低時長/FPS/品質/強度');
                        this.hideProgress();
                        this.setButtonsState(false);
                        // 匯出失敗後恢復即時動畫
                        if (!this.animationId) this.animate();
                        return;
                    }
                }
                
                this.hideProgress();
                this.setButtonsState(false);
                // 匯出完成後恢復即時動畫
                if (!this.animationId) this.animate();
            }
            
            async downloadMp4() {
                this.setButtonsState(true);
                this.showProgress('正在錄製並轉檔 MP4...');
                
                const fps = parseInt(document.getElementById('fps').value);
                const duration = parseInt(document.getElementById('duration').value);
                const quality = parseFloat(document.getElementById('quality').value);
                
                try {
                    const recordCanvas = document.createElement('canvas');
                    const recordCtx = recordCanvas.getContext('2d', { willReadFrequently: true });
                    recordCanvas.width = this.canvas.width;
                    recordCanvas.height = this.canvas.height;
                    
                    const stream = recordCanvas.captureStream(fps);
                    this.mediaRecorder = new MediaRecorder(stream, {
                        mimeType: 'video/webm;codecs=vp9',
                        videoBitsPerSecond: 5000000 * quality
                    });
                    
                    this.recordedChunks = [];
                    
                    this.mediaRecorder.ondataavailable = (event) => {
                        if (event.data.size > 0) {
                            this.recordedChunks.push(event.data);
                        }
                    };
                    
                    this.mediaRecorder.onstop = async () => {
                        try {
                            const webmBlob = new Blob(this.recordedChunks, {type: 'video/webm'});
                            this.showProgress('正在轉檔為 MP4 (瀏覽器端轉檔)...');
                            const mp4Blob = await this.convertWebmToMp4(webmBlob);
                            const url = URL.createObjectURL(mp4Blob);
                            const a = document.createElement('a');
                            a.href = url;
                            a.download = `effect_${this.effectType}_${Date.now()}.mp4`;
                            a.click();
                            URL.revokeObjectURL(url);
                        } catch (e) {
                            console.error('轉檔 MP4 失敗，改下載 WebM：', e);
                            // 回退：提供 WebM
                            const blob = new Blob(this.recordedChunks, {type: 'video/webm'});
                            const url = URL.createObjectURL(blob);
                            const a = document.createElement('a');
                            a.href = url;
                            a.download = `effect_${this.effectType}_${Date.now()}.webm`;
                            a.click();
                            URL.revokeObjectURL(url);
                            alert('瀏覽器端轉檔 MP4 失敗，已改下載 WebM。可用 ffmpeg 桌面工具轉檔。');
                        } finally {
                            this.hideProgress();
                            this.setButtonsState(false);
                        }
                    };
                    
                    // 開始錄製
                    this.mediaRecorder.start();
                    
                    const totalFrames = fps * duration;
                    let frameIndex = 0;
                    
                    const renderFrame = () => {
                        if (frameIndex >= totalFrames) {
                            this.mediaRecorder.stop();
                            return;
                        }
                        
                        // 繪製底圖
                        recordCtx.clearRect(0, 0, recordCanvas.width, recordCanvas.height);
                        if (this.isImage) {
                            recordCtx.drawImage(this.mediaElement, 0, 0, recordCanvas.width, recordCanvas.height);
                        } else {
                            recordCtx.drawImage(this.mediaElement, 0, 0, recordCanvas.width, recordCanvas.height);
                        }
                        
                        // 在臨時上下文上渲染特效
                        this.particles.forEach((particle, index) => {
                            this.updateParticle(particle, index);
                            this.ctx = recordCtx;
                            this.drawParticle(particle, index);
                        });
                        this.ctx = this.canvas.getContext('2d', { willReadFrequently: true });
                        
                        frameIndex++;
                        const progress = (frameIndex / totalFrames) * 100;
                        this.updateProgress(progress, `生成幀 ${frameIndex}/${totalFrames}`);
                        
                        // 以固定幀率遞迴
                        setTimeout(renderFrame, 1000 / fps);
                    };
                    
                    this.showProgress('正在生成 MP4 影片...');
                    renderFrame();
                } catch (error) {
                    console.error('MP4 generation failed:', error);
                    alert('MP4 生成失敗，請重試');
                    this.hideProgress();
                    this.setButtonsState(false);
                }
            }
            
            downloadImage() {
                try {
                    const outCanvas = document.createElement('canvas');
                    const outCtx = outCanvas.getContext('2d');
                    outCanvas.width = this.canvas.width;
                    outCanvas.height = this.canvas.height;
                    
                    // 底圖
                    if (this.isImage) {
                        outCtx.drawImage(this.mediaElement, 0, 0, outCanvas.width, outCanvas.height);
                    } else {
                        outCtx.drawImage(this.mediaElement, 0, 0, outCanvas.width, outCanvas.height);
                    }
                    
                    // 特效（以目前畫面為主）
                    outCtx.drawImage(this.canvas, 0, 0);
                    
                    const url = outCanvas.toDataURL('image/png');
                    const a = document.createElement('a');
                    a.href = url;
                    a.download = `effect_${this.effectType}_${Date.now()}.png`;
                    a.click();
                } catch (error) {
                    console.error('Image download failed:', error);
                    alert('圖片下載失敗，請重試');
                }
            }
            
            setButtonsState(disabled) {
                const ids = ['downloadGifBtn', 'downloadMp4Btn', 'downloadImageBtn'];
                ids.forEach(id => {
                    const btn = document.getElementById(id);
                    if (btn) btn.disabled = disabled;
                });
            }
            
            showProgress(text) {
                const bar = document.getElementById('progressBar');
                const fill = document.getElementById('progressFill');
                const txt = document.getElementById('progressText');
                if (bar && fill && txt) {
                    bar.style.display = 'block';
                    fill.style.width = '0%';
                    txt.textContent = text || '';
                }
            }
            
            updateProgress(percent, text) {
                const fill = document.getElementById('progressFill');
                const txt = document.getElementById('progressText');
                if (fill) fill.style.width = `${Math.max(0, Math.min(100, percent))}%`;
                if (txt && text !== undefined) txt.textContent = text;
            }
            
            hideProgress() {
                const bar = document.getElementById('progressBar');
                const txt = document.getElementById('progressText');
                if (bar) bar.style.display = 'none';
                if (txt) txt.textContent = '';
            }
        }
        
        // 初始化
        window.addEventListener('load', () => {
            try {
                window.__engine = new EnhancedEffectEngine();
            } catch (e) {
                console.error('初始化失敗:', e);
            }
        });
    </script>
</body>
</html>